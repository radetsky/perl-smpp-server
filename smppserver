#!/usr/bin/env perl 
#===============================================================================
#
#         FILE:  smppd.pl
#
#        USAGE:  ./smppd.pl
#
#  DESCRIPTION:  NetSDS SMPP Server
#
#      OPTIONS:  ---
# REQUIREMENTS:
#         BUGS:  ---
#        NOTES:  ---
#       AUTHOR:  Michael Bochkaryov (Rattler), <misha@rattler.kiev.ua>
#      COMPANY:  Net.Style
#      VERSION:  1.0
#      CREATED:  12.07.2009 15:15:03 UTC
#     REVISION:  ---
#     MODIFIED:  Alex Radetsky (rad), <rad@rad.kiev.ua>
#===============================================================================

use 5.8.0;
use strict;
use warnings;

SMPPServerV2->run(
	daemon      => undef,
	verbose     => 1,
	use_pidfile => 1,
	has_conf    => 1,
	conf_file   => "./smppserver.conf",
	debug       => 1
);

1;

package SMPPServerV2;

use 5.8.0;
use strict;
use warnings;

use base qw(NetSDS::App::SMPPServer);

use NetSDS::Util::Convert;
use NetSDS::Util::DateTime;
use NetSDS::Util::String;
use NetSDS::Util::Misc;
use NetSDS::Queue;
use NetSDS::App::SMSTradeOutQ;
use NetSDS::App::SMSTradeInQ;

use IPC::ShareLite;
use JSON;

use DBI;

use Time::HiRes qw(usleep);

use Data::Dumper;

my @CHILDREN = array();
my $ESME     = undef;

sub initialize {

	my ( $this, %params ) = @_;

	$this->speak("[$$] SMPPServerV2 Initializing application.");
	# Determine application name from process name
	if ( !$this->{name} ) {
		$this->_determine_name();
	}

	# Get CLI parameters
	$this->_get_cli_param();

	# Create syslog handler
	if ( !$this->logger ) {
		$this->logger( NetSDS::Logger->new( name => $this->{name} ) );
		$this->log( "info", "Logger started" );
	}

	# Initialize EDR writer
	if ( $this->edr_file ) {
		$this->{edr_writer} = NetSDS::EDR->new( filename => $this->edr_file );
	}

	# Initialize configuration
	if ( $this->{has_conf} ) {

		# Automatically determine configuration file name
		if ( !$this->{conf_file} ) {
			$this->{conf_file} = $this->config_file( $this->{name} . ".conf" );
		}

		# Get configuration file
		if ( my $conf = NetSDS::Conf->getconf( $this->{conf_file} ) ) {
			$this->conf($conf);
			$this->log( "info", "Configuration file read OK: " . $this->{conf_file} );
		} else {
			$this->log( "error", "Can't read configuration file: " . $this->{conf_file} );
		}

		# Add automatic features
		if ( $this->auto_features ) {
			$this->use_auto_features();
		}

	} ## end if ( $this->{has_conf})

	# Daemonize, if needed
	if ( $this->daemon() ) {
		$this->speak("[$$]Daemonize, switch verbosity to false.");
		$this->{verbose} = undef;
		Proc::Daemon::Init;
	}

    # Process PID file if necessary
	if ( $this->use_pidfile  ) {
		if ( Proc::PID::File->running( dir => $this->pid_dir, name => $this->{name} ) ) {
			$this->log( "error", "Application already running, stop immediately!" );
			die "Application already running, stop immediately!";
		}
	}

	# Update PID if necessary
	$this->{pid} = $$;

	$this->_burn_children();

	# Add signal handlers
	$SIG{INT} = sub {
		$this->speak("SIGINT caught");
		$this->log( "warn", "SIGINT caught" );
		my $perm = kill "TERM" => @CHILDREN;
		$this->speak("Sent TERM to $perm processes");
		$this->{to_finalize} = 1;
	};

	$SIG{TERM} = sub {
		$this->speak("SIGTERM caught");
		$this->log( "warn", "SIGTERM caught" );
		my $perm = kill "TERM" => @CHILDREN;
		$this->speak("Sent TERM to $perm processes");
		$this->{to_finalize} = 1;
	};

	# Initialize signals processing
	# $this->set_signal_processors();

	# Create select() handler for incoming events
	$this->selector( IO::Select->new() );

	# Initialize queue listener for outgoing events
	$this->_init_out_queue();
	$this->selector->add( $this->out_queue );

	# Initialize queue for incoming (MT) events
	$this->_init_in_queue();

	# Initialize listening socket and add to select()
	$this->_init_listener();
	$this->selector->add( $this->listener );

	# Set initial empty array of handlers hashref
	$this->handlers( {} );

	# Initialize SHM area
	$this->_init_shm();

} ## end sub initialize

sub _burn_children {

	my ( $this, %params ) = @_;

	# Out Q
	$this->speak("[$$] Forking Outgoing Queue Plugin");
	my $pid = fork();
	unless ( defined($pid) ) {
		die "[$$] Fork() for Outgoing Queue Plugin failed: $!";
	}
	if ( $pid == 0 ) {
		$this->speak("[$$] Running NetSDS::App::SMSTradeOutQ");
		my $smsout = new NetSDS::App::SMSTradeOutQ();
		$smsout->{conf} = $this->{conf};  
		$smsout->run();
		die "[$$] NetSDS::App::SMSTradeInQ died.";
	}
	push @CHILDREN, $pid;

	# In Q
	$this->speak("[$$] Forking Incoming Queue Plugin");
	$pid = fork();
	unless ( defined($pid) ) {
		die "[$$] Fork() for Incoming Queue Plugin failed: $!";
	}
	if ( $pid == 0 ) {
		$this->speak("[$$] Running NetSDS::App::SMSTradeInQ");
		my $smsin = new NetSDS::App::SMSTradeInQ();
		$smsin->{conf} = $this->{conf}; 
		$smsin->run();
		die "[$$] NetSDS::App::SMSTradeInQ died.";
	}
	push @CHILDREN, $pid;

} ## end sub _burn_children

sub start {

	my ($this) = @_;

	$this->speak("[$$] Start SMPPServerV2 ");

	# Connect to authentication DBMS
	$this->mk_accessors('authdbh');
	$this->_connect_db;

}

sub _auth_esme {

	my ( $this, $login, $passwd ) = @_;

	# Check DBMS connection and do reconnect if necessary
	$this->_connect_db();

	# Execute SQL query (should be present in configuration file)
	my $sth = $this->authdbh->prepare( $this->conf->{auth}->{query} );
	$sth->execute( $login, $passwd );

	# Try to get one row or return undef
	if ( my $res = $sth->fetchrow_hashref() ) {

		my $system_id = $res->{'system_id'};
		$ESME->{$system_id} = $res;

		unless ( defined( $ESME->{$system_id}->{'already_connected'} ) ) {    # no connections ?
			$ESME->{$system_id}->{'already_connected'} = 0;
		}

		# if database does not contain max_connections for ESME, default value = 1
		$this->speak( "max_connections for " . $system_id . " is NULL. Default value set to 1. " );
		unless ( defined( $ESME->{$system_id}->{'max_connections'} ) ) {
			$ESME->{$system_id}->{'max_connections'} = 1;
		}

		# increase already_connected

		$ESME->{$system_id}->{'already_connected'} = $ESME->{$system_id}->{'already_connected'} + 1;
		if ( $ESME->{$system_id}->{'already_connected'} > $ESME->{$system_id}->{'max_connections'} ) {
			return undef;    # Do not authorize.
		}

		return 1;

	} else {

		return undef;

	}
} ## end sub _auth_esme

sub _connect_db {

	my ($this) = @_;

	my $dsn    = $this->conf->{'auth'}->{'dsn'};
	my $user   = $this->conf->{'auth'}->{'db-user'};
	my $passwd = $this->conf->{'auth'}->{'db-password'};

	# $this->speak("[$$] Current DSN='".$dsn."'");

	# If DBMS isn' t accessible - try reconnect
	if ( !$this->authdbh or !$this->authdbh->ping ) {
		$this->authdbh( DBI->connect_cached( $dsn, $user, $passwd ) );

		#		$this->authdbh->do("SET CLIENT_ENCODING TO 'UTF-8'");
		#		$this->authdbh->do("SET DATESTYLE TO 'ISO'");

	}

	if ( !$this->authdbh ) {
		$this->speak("Cant connect to DBMS!");
		$this->log( "error", "Cant connect to DBMS!" );
	}

} ## end sub _connect_db

=item B<_init_out_queue) 

Connects to socket of Mobile Terminated Queue Hadler. 

=cut 

sub _init_out_queue {

	my ( $this, %params ) = @_;

	use constant OUT_QUEUE_ADDR  => '127.0.0.1';
	use constant OUT_QUEUE_PORT  => '9999';
	use constant OUT_QUEUE_PROTO => 'tcp';

	my $out_queue_addr  = undef;
	my $out_queue_port  = undef;
	my $out_queue_proto = undef;

	unless ( defined( $this->conf->{'out_queue'}->{'addr'} ) ) {
		$out_queue_addr = OUT_QUEUE_ADDR;
	} else {
		$out_queue_addr = $this->conf->{'out_queue'}->{'addr'};
	}

	unless ( defined( $this->conf->{'out_queue'}->{'port'} ) ) {
		$out_queue_port = OUT_QUEUE_PORT;
	} else {
		$out_queue_port = $this->conf->{'out_queue'}->{'port'};
	}

	unless ( defined( $this->conf->{'out_queue'}->{'proto'} ) ) {
		$out_queue_proto = OUT_QUEUE_PROTO;
	} else {
		$out_queue_proto = $this->conf->{'out_queue'}->{'proto'};
	}

	# Connect to remote socket

	my $connect_failed = 0;

	out_queue_connect:

	$this->out_queue(
		IO::Socket::INET->new(
			PeerAddr => $out_queue_addr,
			PeerPort => $out_queue_port,
			Proto    => $out_queue_proto,
		)
	);

	unless ( defined( $this->out_queue ) ) {
		sleep(1);
		$connect_failed++;
		if ( $connect_failed > 5 ) {

			$this->log(
				"error",
				sprintf(
					"Cant connect to ougoing queue server at %s:%s/%s",
					$out_queue_addr,
					$out_queue_port,
					$out_queue_proto
				)
			);

			die(
				sprintf(
					"ERROR! Cant connect to outgoing queue server at %s:%s/%s",
					$out_queue_addr,
					$out_queue_port,
					$out_queue_proto
				)
			);
		} ## end if ( $connect_failed >...
		goto out_queue_connect;
	} ## end unless ( defined( $this->out_queue...

	$this->out_queue->autoflush(1);

	$this->log( "info", "Successfully connected to OUT Queue server" );

} ## end sub _init_out_queue

sub _init_in_queue {

	my ( $this, %params ) = @_;

	use constant IN_QUEUE_ADDR  => '127.0.0.1';
	use constant IN_QUEUE_PORT  => '9998';
	use constant IN_QUEUE_PROTO => 'tcp';

	my $in_queue_addr  = undef;
	my $in_queue_port  = undef;
	my $in_queue_proto = undef;

	unless ( defined( $this->conf->{'in_queue'}->{'addr'} ) ) {
		$in_queue_addr = IN_QUEUE_ADDR;
	} else {
		$in_queue_addr = $this->conf->{'in_queue'}->{'addr'};
	}

	unless ( defined( $this->conf->{'in_queue'}->{'port'} ) ) {
		$in_queue_port = IN_QUEUE_PORT;
	} else {
		$in_queue_port = $this->conf->{'in_queue'}->{'port'};
	}

	unless ( defined( $this->conf->{'in_queue'}->{'proto'} ) ) {
		$in_queue_proto = IN_QUEUE_PROTO;
	} else {
		$in_queue_proto = $this->conf->{'in_queue'}->{'proto'};
	}

	# Connect to remote socket

	my $connect_failed = 0;

	in_queue_connect:

	$this->in_queue(
		IO::Socket::INET->new(
			PeerAddr => $in_queue_addr,
			PeerPort => $in_queue_port,
			Proto    => $in_queue_proto,
		)
	);

	unless ( defined( $this->in_queue ) ) {
		sleep(1);
		$connect_failed++;
		if ( $connect_failed > 5 ) {

			$this->log(
				"error",
				sprintf(
					"Cant connect to incoming queue server at %s:%s/%s",
					$in_queue_addr,
					$in_queue_port,
					$in_queue_proto
				)
			);

			die(
				sprintf(
					"ERROR! Cant connect to incoming queue server at %s:%s/%s",
					$in_queue_addr,
					$in_queue_port,
					$in_queue_proto
				)
			);
		} ## end if ( $connect_failed >...
		goto in_queue_connect;
	} ## end unless ( defined( $this->in_queue...

	$this->in_queue->autoflush(1);

	$this->log( "info", "Successfully connected to INcoming Queue server" );

} ## end sub _init_in_queue

=item B<cmd_submit_sm> 

We are replaced parent method because we need to sent message to IO::Socket::INET not MemcacheQ. 

=cut 

sub cmd_submit_sm {

	my ( $this, $pdu, $hdl ) = @_;

	my %COD_NAME = (
		0 => 'gsm0338',
		1 => '8bit',
		2 => 'ucs2',
	);

	my $resp_status = undef;    # response command status
	my $message_id  = undef;    # message id on CPA (UUID style)

	# Check if client is authenticated
	if ( $hdl->{authenticated} ) {

		# Create empty message
		my $queue_msg = {
			client   => $hdl->{system_id},
			created  => date_now(),
			received => date_now(),
		};

		unless ( defined( $ESME->{ $hdl->{system_id} } ) ) {
			$queue_msg->{'esme_id'} = undef;
			# FIXME: try to reload user data

		} else {
			$queue_msg->{'esme_id'} = $ESME->{ $hdl->{system_id} }->{'esme_id'};
		}

		my $mclass = undef;    # default (ME specific according with GSM 03.38)

		# Create UUID for new MT message
		$message_id = make_uuid();
		$queue_msg->{message_id} = $message_id;

		# Get source and destination addresses
		#	my $src_addr = $pdu->{source_addr};
		#   my $dst_addr = $pdu->{destination_addr};

		$queue_msg->{src_addr} = $pdu->{source_addr};
		$queue_msg->{dst_addr} = $pdu->{destination_addr};

		# **************************************************************************
		#
		# Process data_coding (see ETSI GSM 03.38 specification)
		#
		# Determine: message_class, coding, MWI flags
		#
		my $data_coding = $pdu->{data_coding};

		# Check if message_class is present
		if ( ( $data_coding & 0b00010000 ) eq 0b00010000 ) {
			$mclass = $data_coding & 0b00000011;
		}
		$queue_msg->{mclass} = $mclass;

		# Determine coding
		my $coding = ( $data_coding & 0b00001100 ) >> 2;
		#$queue_msg->{coding_integer} = $coding;

		$queue_msg->{coding} = $coding;

		# Determine UDHI state
		my $udhi      = 0;                    # No UDH by default
		my $esm_class = $pdu->{esm_class};    # see 5.2.12 part of SMPP 3.4 spec
		if ( ( $esm_class & 0b01000000 ) eq 0b01000000 ) {
			$udhi = 1;
		}

		# **************************************************************************
		#
		# Process SM body (UD and UDH)
		#
		my $msg_text = $pdu->{short_message};

		# If have UDH, get if from message
		my $udh = undef;
		if ($udhi) {
			use bytes;
			my ($udhl) = unpack( "C*", bytes::substr( $msg_text, 0, 1 ) );
			$udh = bytes::substr( $msg_text, 0, $udhl + 1 );
			$msg_text = bytes::substr( $msg_text, $udhl + 1 );
			no bytes;
			$queue_msg->{udh} = conv_str_hex($udh);
		}

		# Encode User Data (UD)
		$queue_msg->{body} = conv_str_hex($msg_text);

		# Check if need DLR for message
		if ( $pdu->{registered_delivery} ) {
			$queue_msg->{register_delivery} = '1';
		}

		# Determine TTL for the message
		my $validity_period = $pdu->{validity_period};
		if ( $validity_period =~ /(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(\d)(\d\d)([\-\+R])/ ) {
			$queue_msg->{validity} = "20" . $1 . "-" . $2 . "-" . $3 . " " . $4 . ":" . $5 . ":" . $6;
		}

		# Determine deferred delivery time
		my $schedule_delivery_time = $pdu->{schedule_delivery_time};
		if ( $schedule_delivery_time =~ /(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(\d)(\d\d)([\-\+R])/ ) {
			$queue_msg->{deferred} = "20" . $1 . "-" . $2 . "-" . $3 . " " . $4 . ":" . $5 . ":" . $6;
		}

		# Determine priority
		if ( $pdu->{priority_flag} ) {
			$queue_msg->{priority} = $pdu->{priority_flag} + 0;
		}

		$this->log(
			"info",
			sprintf(
				"MT SM submitted: id='%s', from='%s', to='%s'",
				$queue_msg->{message_id},
				$queue_msg->{src_addr},
				$queue_msg->{dst_addr}
			)
		);

		# Encoding queue_msg to JSON pretty
		my $json_text = to_json( $queue_msg, { ascii => 1, pretty => 1 } );

		# Sending to IN Queue
		my $res = $this->in_queue->print( conv_str_base64($json_text) . "\n" );

		if ( !$res ) {
			$resp_status = 0x45;    # ESME_RSUBMITFAIL
		}

	} else {
		$resp_status = 0x45;        # ESME_RSUBMITFAIL
	}

	# Send response to ESME
	# Note: we use asynchronous sending to avoid deadlocks
	$hdl->{smpp}->submit_sm_resp(
		seq        => $pdu->{seq},
		status     => $resp_status,
		message_id => $message_id,
		async      => 1,
	);

} ## end sub cmd_submit_sm

sub cmd_unbind {

	my ( $this, $pdu, $hdl ) = @_;

	# warn "[$$] ". Dumper ($pdu);
	my $system_id = $hdl->{system_id};

	my $resp = $hdl->{smpp}->unbind_resp(
		seq    => $pdu->{seq},
		status => $pdu->{status},
	);

	# Remove socket from select()
	$this->selector->remove( $hdl->{smpp} );

	# Close socket and remove record
	$hdl->{smpp}->close();
	undef $this->{handlers}->{ $hdl->{id} };

	# Update SHM struture (only for defined system_id)
	if ( $hdl->{system_id} ) {
		$this->shm->lock;
		my $list = decode_json( $this->shm->fetch );
		delete $list->{ $hdl->{system_id} };
		$this->shm->store( encode_json($list) );
		$this->shm->unlock;
	}

	# decrease already connected value for system_id
	$ESME->{$system_id}->{'already_connected'} = $ESME->{$system_id}->{'already_connected'} - 1;

}    # end sub cmd unbind

#
# bind_transiever called when ESME connect to us in transiever mode (send and receive SMS in one connection )
#

sub cmd_bind_transceiver {

	my ( $this, $pdu, $hdl ) = @_;

	# Determine incoming login (system-id) and password
	my $login  = $pdu->{system_id};
	my $passwd = $pdu->{password};

	my $resp_status = 0x00000000;    # All OK

	# Send error status if already authenticated
	if ( $hdl->{authenticated} ) {

		$this->log( "warning", "Already binded ESME authentication: $login" );
		$resp_status = 0x00000005;    # Already in bind state

	} else {

		# Authentication
		if ( $this->_auth_esme( $login, $passwd ) ) {
			$this->speak("ESME '$login' successfully authenticated");
			$this->log( "info", "ESME '$login' successfully authenticated" );

			# Update handlers
			$this->{handlers}->{ $hdl->{id} }->{authenticated} = 1;
			$this->{handlers}->{ $hdl->{id} }->{system_id}     = $login;
			$this->{handlers}->{ $hdl->{id} }->{mode}          = 'transceiver';

			# Update SHM struture
			my $list = decode_json( $this->shm->fetch );
			$list->{$login} = 1;
			$this->shm->lock;
			$this->shm->store( encode_json($list) );
			$this->shm->unlock;

		} else {
			$this->log( "warning", "Cant authenticate ESME: [$login:$passwd]" );
			$this->speak("Cant authenticate ESME: [$login:$passwd]");
			$resp_status = 0x0000000E;    # ESME_RINVPASWD

			# Send ESME_RINVPASWD
			my $resp = $hdl->{smpp}->bind_transceiver_resp(
				seq       => $pdu->{seq},
				status    => $resp_status,
				system_id => NetSDS::App::SMPP::SYSTEM_NAME,
			);

			# Close socket
			# Remove socket from select()
			$this->selector->remove( $hdl->{smpp} );

			# Close socket and remove record
			$hdl->{smpp}->close();
			undef $this->{handlers}->{ $hdl->{id} };

			# Update SHM struture (only for defined system_id)
			if ( $hdl->{system_id} ) {
				$this->shm->lock;
				my $list = decode_json( $this->shm->fetch );
				delete $list->{ $hdl->{system_id} };
				$this->shm->store( encode_json($list) );
				$this->shm->unlock;
			}

			return undef;

		} ## end else [ if ( $this->_auth_esme...

		my $resp = $hdl->{smpp}->bind_transceiver_resp(
			seq       => $pdu->{seq},
			status    => $resp_status,                     # ESME_ROK
			system_id => NetSDS::App::SMPP::SYSTEM_NAME,
		);

	} ## end else [ if ( $hdl->{authenticated...

} ## end sub cmd_bind_transceiver

sub cmd_bind_transmitter {

	my ( $this, $pdu, $hdl ) = @_;

	# Determine incoming login (system-id) and password
	my $login  = $pdu->{system_id};
	my $passwd = $pdu->{password};

	my $resp_status = 0x00000000;    # All OK

	# Send error status if already authenticated
	if ( $hdl->{authenticated} ) {

		$this->log( "warning", "Already binded ESME authentication: $login" );
		$resp_status = 0x00000005;    # Already in bind state

	} else {

		# FIXME
		# Authentication
		if ( $this->_auth_esme( $login, $passwd ) ) {
			$this->speak("ESME '$login' successfully authenticated");
			$this->log( "info", "ESME '$login' successfully authenticated" );

			# Update handlers
			$this->{handlers}->{ $hdl->{id} }->{authenticated} = 1;
			$this->{handlers}->{ $hdl->{id} }->{system_id}     = $login;
			$this->{handlers}->{ $hdl->{id} }->{mode}          = 'transmitter';

		} else {
			$this->log( "warning", "Cant authenticate ESME: [$login:$passwd]" );
			$this->speak("Cant authenticate ESME: [$login:$passwd]");
			$resp_status = 0x0000000E;    # ESME_RINVPASWD
			my $resp = $hdl->{smpp}->bind_transmitter_resp(
				seq       => $pdu->{seq},
				status    => $resp_status,                     # ESME_RINVPASWD
				system_id => NetSDS::App::SMPP::SYSTEM_NAME,
			);
			# Close socket
			# Remove socket from select()
			$this->selector->remove( $hdl->{smpp} );

			# Close socket and remove record
			$hdl->{smpp}->close();
			undef $this->{handlers}->{ $hdl->{id} };

			# Update SHM struture (only for defined system_id)
			if ( $hdl->{system_id} ) {
				$this->shm->lock;
				my $list = decode_json( $this->shm->fetch );
				delete $list->{ $hdl->{system_id} };
				$this->shm->store( encode_json($list) );
				$this->shm->unlock;
			}

			return undef;

		} ## end else [ if ( $this->_auth_esme...

		my $resp = $hdl->{smpp}->bind_transmitter_resp(
			seq       => $pdu->{seq},
			status    => $resp_status,                     # ESME_ROK
			system_id => NetSDS::App::SMPP::SYSTEM_NAME,
		);

	} ## end else [ if ( $hdl->{authenticated...

} ## end sub cmd_bind_transmitter

sub cmd_bind_receiver {

	my ( $this, $pdu, $hdl ) = @_;

	# Determine incoming login (system-id) and password
	my $login  = $pdu->{system_id};
	my $passwd = $pdu->{password};

	my $resp_status = 0x00000000;    # All OK

	# Send error status if already authenticated
	if ( $hdl->{authenticated} ) {

		$this->log( "warning", "Already binded ESME authentication: $login" );
		$resp_status = 0x00000005;    # Already in bind state

	} else {

		# FIXME
		# Authentication
		if ( $this->_auth_esme( $login, $passwd ) ) {
			$this->speak("ESME '$login' successfully authenticated");
			$this->log( "info", "ESME '$login' successfully authenticated" );

			# Update handlers
			$this->{handlers}->{ $hdl->{id} }->{authenticated} = 1;
			$this->{handlers}->{ $hdl->{id} }->{system_id}     = $login;
			$this->{handlers}->{ $hdl->{id} }->{mode}          = 'receiver';

			# Update SHM struture
			my $list = decode_json( $this->shm->fetch );
			$list->{$login} = 1;
			$this->shm->lock;
			$this->shm->store( encode_json($list) );
			$this->shm->unlock;

		} else {
			$this->log( "warning", "Cant authenticate ESME: [$login:$passwd]" );
			$this->speak("Cant authenticate ESME: [$login:$passwd]");
			$resp_status = 0x0000000E;    # ESME_RINVPASWD

			my $resp = $hdl->{smpp}->bind_receiver_resp(
				seq       => $pdu->{seq},
				status    => $resp_status,                     # ESME_RINVPASWD
				system_id => NetSDS::App::SMPP::SYSTEM_NAME,
			);

			# Close socket
			# Remove socket from select()
			$this->selector->remove( $hdl->{smpp} );

			# Close socket and remove record
			$hdl->{smpp}->close();
			undef $this->{handlers}->{ $hdl->{id} };

			# Update SHM struture (only for defined system_id)
			if ( $hdl->{system_id} ) {
				$this->shm->lock;
				my $list = decode_json( $this->shm->fetch );
				delete $list->{ $hdl->{system_id} };
				$this->shm->store( encode_json($list) );
				$this->shm->unlock;
			}

			return undef;

		} ## end else [ if ( $this->_auth_esme...

		my $resp = $hdl->{smpp}->bind_receiver_resp(
			seq       => $pdu->{seq},
			status    => $resp_status,                     # ESME_ROK
			system_id => NetSDS::App::SMPP::SYSTEM_NAME,
		);

	} ## end else [ if ( $hdl->{authenticated...

} ## end sub cmd_bind_receiver

sub _process_out_queue {
	my ( $this, %params ) = @_;

	# Try to get next line from Queue server over TCP socket
	if ( my $line = $this->out_queue->getline() ) {

		# Return if keepalive
		if ( $line =~ '-MARK-' ) {
			$this->speak("Keepalive from queue server");
			return 1;
		}

		# FIXME - provide incorrect data handling
		my $mo = decode_json( conv_base64_str($line) );

		use Data::Dumper;
		# Check if exist in MO esme_id
		unless ( defined( $mo->{'esme_id'} ) ) {
			$this->speak("[$$] MO with empty esme_id");
			$this->log( "warning", "MO with empty esme_id" );
		} else {
			# esme_id is not empty, searching system_id and socket
			foreach my $esme ( keys %$ESME ) {
				unless ( defined( $ESME->{$esme}->{'esme_id'} ) ) { next; }
				if ( $ESME->{$esme}->{'esme_id'} eq $mo->{'esme_id'} ) {
					$mo->{'system_id'} = $esme;
					last;
				}
			}
			# Looking for proper ESME connect

			my $esme_connect_found = undef;
			foreach my $hdl ( values %{ $this->handlers } ) {
				#warn "[$$] hdl ". Dumper ($hdl);
				unless ( defined( $hdl->{system_id} ) ) { next; }
				if ( $hdl->{system_id} eq $mo->{'system_id'} ) {
					if ( ( $hdl->{mode} eq 'transceiver' ) or ( $hdl->{mode} eq 'receiver' ) ) {
						# warn "[$$] Call _deliver_sm with MO: ". Dumper ($mo);
						$this->_deliver_sm( $hdl, $mo );    # send deliver_sm to ESME
						$this->out_queue->print("OK\n");
						$esme_connect_found = 1;
					}
				}
			}
			unless ( defined($esme_connect_found) ) {
				$this->speak( "[$$] ESME " . $mo->{'system_id'} . "not found in active list. " );
				$this->log( "warning", "ESME " . $mo->{'system_id'} . "not found in active list. " );
				$this->out_queue->print("ERROR\n");
			}

		} ## end else

	} ## end if ( my $line = $this->out_queue...
} ## end sub _process_out_queue

sub _deliver_sm {

	my ( $this, $hdl, $mo ) = @_;

	if ( $mo->{id} ) {

		# Set default parameters (for MO SM)
		my $message_id       = $mo->{id};
		my $esm_class        = 0x00;
		my $source_addr_ton  = 0x01;
		my $source_addr_npi  = 0x01;
		my $source_addr      = $mo->{src_addr};
		my $dest_addr_ton    = 0x00;
		my $dest_addr_npi    = 0x01;
		my $destination_addr = $mo->{dst_addr};
		my $msg_text         = $mo->{text};
		my $data_coding      = $mo->{coding};

		# Set ESM class
		if ( $mo->{dlr} ) {
			$esm_class = 0x04;    # DLR
		}

		# Send deliver_sm
		$hdl->{smpp}->deliver_sm(
			source_addr_ton  => $source_addr_ton,    # International (MSISDN)
			source_addr_npi  => $source_addr_npi,    # E.164
			source_addr      => $source_addr,
			dest_addr_ton    => $dest_addr_ton,      # Unknown (default)
			dest_addr_npi    => $dest_addr_npi,      # E.164
			destination_addr => $destination_addr,
			esm_class        => $esm_class,          # MO data (UDH + UD) or DLR
			short_message    => $msg_text,
			async            => 1,
			data_coding      => $data_coding,
		);

	} ## end if ( $mo->{id} )

	$hdl->{out_seq}++;
} ## end sub _deliver_sm

1;
#===============================================================================

__END__

=head1 NAME

smppd.pl

=head1 SYNOPSIS

smppd.pl

=head1 DESCRIPTION

FIXME

=head1 EXAMPLES

FIXME

=head1 BUGS

Unknown.

=head1 TODO

Empty.

=head1 AUTHOR

Michael Bochkaryov <misha@rattler.kiev.ua>
Alex Radetsky <rad@rad.kiev.ua>


=cut

