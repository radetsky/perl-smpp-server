#!/usr/bin/env perl 
#===============================================================================
#
#         FILE:  smppd.pl
#
#        USAGE:  ./smppd.pl
#
#  DESCRIPTION:  NetSDS SMPP Server
#
#      OPTIONS:  ---
# REQUIREMENTS:
#         BUGS:  ---
#        NOTES:  ---
#       AUTHOR:  Michael Bochkaryov (Rattler), <misha@rattler.kiev.ua>
#      COMPANY:  Net.Style
#      VERSION:  1.0
#      CREATED:  12.07.2009 15:15:03 UTC
#     REVISION:  ---
#     MODIFIED:  Alex Radetsky (rad), <rad@rad.kiev.ua>
#===============================================================================

use 5.8.0;
use strict;
use warnings;

SMPPServerV2->run(
	daemon      => undef,
	verbose     => 1,
	use_pidfile => 1,
	has_conf    => 1,
	debug       => undef,
	conf_file   => "./smppserver.conf",
);

1;

package SMPPServerV2;

use 5.8.0;
use strict;
use warnings;

use base qw(NetSDS::App::SMPPServer);

use NetSDS::Util::Convert;
use NetSDS::Util::SMPPConvert;
use NetSDS::Util::DateTime;
use NetSDS::Util::String;
use NetSDS::Util::Misc;
use NetSDS::Queue;
use NetSDS::App::SMSTradeOutQ;
#use NetSDS::App::SMSTradeInQ;
use NetSDS::App::SMSTradeInDB;
use IPC::ShareLite qw ( :lock );
use JSON;
use DBI;
use Time::HiRes qw(usleep);
use Data::Dumper;
use POSIX qw(floor);
use Encode;
use Socket;
use IO::Handle;

# SMPP PDU command_id table
use constant cmd_tab => {
	0x80000000 => 'generic_nack',
	0x00000001 => 'bind_receiver',
	0x80000001 => 'bind_receiver_resp',
	0x00000002 => 'bind_transmitter',
	0x80000002 => 'bind_transmitter_resp',
	0x00000003 => 'query_sm',
	0x80000003 => 'query_sm_resp',
	0x00000004 => 'submit_sm',
	0x80000004 => 'submit_sm_resp',
	0x80000005 => 'deliver_sm_resp',
	0x00000006 => 'unbind',
	0x80000006 => 'unbind_resp',
	0x00000007 => 'replace_sm',
	0x80000007 => 'replace_sm_resp',
	0x00000008 => 'cancel_sm',
	0x80000008 => 'cancel_sm_resp',
	0x00000009 => 'bind_transceiver',
	0x80000009 => 'bind_transceiver_resp',
	0x0000000b => 'outbind',
	0x00000015 => 'enquire_link',
	0x80000015 => 'enquire_link_resp',
};

my @CHILDREN           = array();
my $ESME               = undef;
my $LOCAL_SYSTEM_ID    = NetSDS::App::SMPP::SYSTEM_NAME;
my $throttle_timestamp = undef;

sub initialize {

	my ( $this, %params ) = @_;

	$this->speak("[$$] SMPPServerV2 Initializing application.");
	# Determine application name from process name
	if ( !$this->{name} ) {
		$this->_determine_name();
	}

	# Get CLI parameters
	$this->_get_cli_param();

	# Create syslog handler
	if ( !$this->logger ) {
		$this->logger( NetSDS::Logger->new( name => $this->{name} ) );
		$this->log( "info", "Logger started" );
	}

	# Initialize configuration
	if ( $this->{has_conf} ) {

		# Automatically determine configuration file name
		if ( !$this->{conf_file} ) {
			$this->{conf_file} = $this->config_file( $this->{name} . ".conf" );
		}

		# Get configuration file
		if ( my $conf = NetSDS::Conf->getconf( $this->{conf_file} ) ) {
			$this->conf($conf);
			$this->log( "info", "Configuration file read OK: " . $this->{conf_file} );
		} else {
			$this->log( "error", "Can't read configuration file: " . $this->{conf_file} );
		}

		# Add automatic features
		if ( $this->auto_features ) {
			$this->use_auto_features();
		}

	} ## end if ( $this->{has_conf})

	# Daemonize, if needed
	if ( $this->daemon() ) {
		$this->speak("[$$] Daemonize, switch verbosity to false.");
		$this->{verbose} = undef;
		Proc::Daemon::Init;
	}

	# Process PID file if necessary
	if ( $this->use_pidfile ) {
		if ( Proc::PID::File->running( dir => $this->pid_dir, name => $this->{name} ) ) {
			$this->log( "error", "Application already running, stop immediately!" );
			die "Application already running, stop immediately!";
		}
	}

	# Update PID if necessary
	$this->{pid} = $$;

	$this->_burn_children();

	# Add signal handlers
	$SIG{INT} = sub {
		$this->speak("SIGINT caught");
		$this->log( "warn", "SIGINT caught" );
		my $perm = kill "TERM" => @CHILDREN;
		$this->speak("Sent TERM to $perm processes");
		$this->{to_finalize} = 1;
	};

	$SIG{TERM} = sub {
		$this->speak("SIGTERM caught");
		$this->log( "warn", "SIGTERM caught" );
		my $perm = kill "TERM" => @CHILDREN;
		$this->speak("Sent TERM to $perm processes");
		$this->{to_finalize} = 1;
	};
	$SIG{USR1} = sub {
		$this->speak("SIGUSR1 caught");
		$this->log( "info", "SIGUSR1 caught" );
		$this->_kick();      # Seek and destrou
		$this->_reload();    # Reload users configuration

	};
	# Initialize signals processing
	# $this->set_signal_processors();

	# Create select() handler for incoming events
	$this->selector( IO::Select->new() );

	# Initialize queue listener for outgoing events
	# $this->_init_out_queue();
	$this->selector->add( $this->{'socket_out_queue'} );

	# Initialize queue for incoming (MT) events
	my $plugindb = NetSDS::App::SMSTradeInDB->new( $this->{conf} );
	$this->{'plugindb'} = $plugindb;

	# Initialize listening socket and add to select()
	$this->_init_listener();
	$this->selector->add( $this->listener );

	# Set initial empty array of handlers hashref
	$this->handlers( {} );

	# Initialize SHM area
	$this->_init_shm();

	$this->_edr_init();

} ## end sub initialize

sub _edr_init {
	my $this = shift;
	# Initialize EDR writer

	if ( defined( $this->{conf}->{'edr'}->{'type'} ) ) {
		my $edr_type = $this->{conf}->{'edr'}->{'type'};
		if ( $edr_type =~ /database/i ) {
			my $edr = NetSDS::EDR->new(
				type     => 'database',
				dsn      => $this->{conf}->{'edr'}->{'dsn'},
				user     => $this->{conf}->{'edr'}->{'db-user'},
				password => $this->{conf}->{'edr'}->{'db-password'},
				query    => $this->{conf}->{'edr'}->{'query'}
			);
			unless ( defined($edr) ) {
				warn Dumper($edr);
				warn Dumper( $this->{conf}->{'edr'} );
				die "Can't init EDR";
			}
			$this->{edr_writer} = $edr;
			$this->{'edr_mapping'} = $this->{conf}->{'edr'}->{'mapping'};
			$this->log( "info", "EDR database writer started." );

		}
		if ( $edr_type =~ /rawfile/i ) {
			$this->{edr_writer} = NetSDS::EDR->new(
				type     => $edr_type,
				filename => $this->{conf}->{'edr'}->{'filename'}
			);
			$this->log( "info", "EDR rawfile writer started." );
		}
		if ( $edr_type =~ /syslog/i ) {
			$this->{edr_writer} = NetSDS::EDR->new(
				type   => $edr_type,
				prefix => $this->{conf}->{'edr'}->{'prefix'}
			);
			$this->log( "info", "EDR syslog writer started" );
		}

	} ## end if ( defined( $this->{...
} ## end sub _edr_init

sub _edr_write {
	my $this   = shift;
	my $record = shift;
	my $params = $this->{'edr_mapping'};

	if ( defined( $this->{edr_writer} ) ) {
		$this->{edr_writer}->write( $record, $params );
	}

}

sub _burn_children {

	my ( $this, %params ) = @_;

	# Out Q
	$this->speak("[$$] Forking Outgoing Queue Plugin");
	my $socket_child  = undef;
	my $socket_parent = undef;

	socketpair( $socket_child, $socket_parent, AF_UNIX, SOCK_STREAM, PF_UNSPEC );
	$socket_child->autoflush(1);
	$socket_parent->autoflush(1);

	my $pid = fork();
	unless ( defined($pid) ) {
		die "[$$] Fork() for Outgoing Queue Plugin failed: $!";
	}
	if ( $pid == 0 ) {
		$this->speak("[$$] Running NetSDS::App::SMSTradeOutQ");
		close $socket_child;
		my $smsout = new NetSDS::App::SMSTradeOutQ();
		$smsout->{conf}          = $this->{conf};
		$smsout->{server_socket} = $socket_parent;
		$smsout->run();
		die "[$$] NetSDS::App::SMSTradeOutQ died.";
	}
	push @CHILDREN, $pid;
	close $socket_parent;
	$this->{'socket_out_queue'} = $socket_child;

	#	# In Q
	#	socketpair($socket_child, $socket_parent, AF_UNIX, SOCK_STREAM, PF_UNSPEC );
	#	$socket_child->autoflush(1);
	#	$socket_parent->autoflush(1);

	#	$this->speak("[$$] Forking Incoming Queue Plugin");
	#	$pid = fork();
	#	unless ( defined($pid) ) {
	#		die "[$$] Fork() for Incoming Queue Plugin failed: $!";
	#	}
	#	if ( $pid == 0 ) {
	#		$this->speak("[$$] Running NetSDS::App::SMSTradeInQ");
	#		close $socket_child;
	#
	#	my $smsin = new NetSDS::App::SMSTradeInQ();
	#	$smsin->{conf} = $this->{conf};
	#	$smsin->{server_socket} = $socket_parent;
	#	$smsin->run();
	#	die "[$$] NetSDS::App::SMSTradeInQ died.";
	#	}
	#	close $socket_parent;
	#	$this->{socket_in_queue} = $socket_child;
	#	push @CHILDREN, $pid;

} ## end sub _burn_children

sub start {

	my ($this) = @_;

	$this->speak("[$$] Start SMPPServerV2 ");
	$this->_edr_write( { event_name => 'Start Server' } );

	# Connect to authentication DBMS
	$this->mk_accessors('authdbh');
	$this->_connect_db;

	# Do you understand what written here ? Yes:No;
	my $my_local_data = defined( $this->conf->{'shm'}->{'magickey'} ) ? $this->conf->{'shm'}->{'magickey'} : 'My L0c4l D4t4';

	$this->shm->lock(LOCK_EX);
	my $list = decode_json( $this->shm->fetch );
	$list->{$my_local_data}->{'start_timestamp'} = time;
	$this->shm->store( encode_json($list) );
	$this->shm->unlock;

	# Fill the Local-system-id value
	if ( defined( $this->conf->{'smpp'}->{'local_system_id'} ) ) {
		$LOCAL_SYSTEM_ID = $this->conf->{'smpp'}->{'local_system_id'};
	}

} ## end sub start

sub _auth_esme {

	my ( $this, $login, $passwd, $addr_port ) = @_;

	# Loggin' begin auth procedure
	$this->log( "info", "Begin authentication for \"$login\"" );
	$this->speak("[$$] Begin authentication for \"$login\"");

	# Check DBMS connection and do reconnect if necessary
	unless ( defined( $this->_connect_db() ) ) {
		return undef;
	}

	# Check config
	unless ( defined( $this->conf->{auth}->{query} ) ) {
		$this->log( "warning", "Undefined main query in auth section of config." );
		return undef;
	}

	unless ( defined( $this->conf->{auth}->{query_system_id} ) ) {
		$this->log( "warning", "Undefined query_system_id in auth section of config." );
		return undef;
	}

	# First of all try to get information with full information like login and password
	# Execute SQL query (should be present in configuration file)
	my $sth = $this->authdbh->prepare( $this->conf->{auth}->{query} );
	my $rv = $sth->execute( $login, $passwd );
	unless ( defined($rv) ) {
		# Execute returns error. Try to reconnect.
		$this->log( "warning", "Can't execute SQL" . $this->conf->{auth}->{query} . " Trying to reconnect. " );
		$this->_connect_db();
		$sth = $this->authdbh->prepare( $this->conf->{auth}->{query} );
		$rv = $sth->execute( $login, $passwd );
		unless ( defined($rv) ) {
			return undef;
		}
	}

	# Try to get one row or return undef
	if ( my $res = $sth->fetchrow_hashref() ) {

		my $system_id = $res->{'system_id'};
		unless ( defined( $ESME->{$system_id} ) ) {    
			# if this record does not exist in hasref ESME
			$ESME->{$system_id} = $res; # add it
		}

		unless ( defined( $ESME->{$system_id}->{'already_connected'} ) ) {    # no connections ?
			$this->log( "info", "Setting already_connected to 0" );
			$ESME->{$system_id}->{'already_connected'} = 0;
		}

		# if database does not contain max_connections for ESME, default value = 1
		unless ( defined( $res->{'max_connections'} ) ) {
			$ESME->{$system_id}->{'max_connections'} = 1;
			$this->log( "warning", "Max_connections for " . $system_id . " is NULL. Default value set to 1. " );
		} else {
			$ESME->{$system_id}->{'max_connections'} = $res->{'max_connections'};
		}

		# if database does not contain allowed_ip, set default to 0.0.0.0
		unless ( defined( $res->{'allowed_ip'} ) ) {
			$ESME->{$system_id}->{'allowed_ip'} = '0.0.0.0';
			$this->log( "warning", "Allowed src ip for " . $system_id . " is NULL. Default value set to 0.0.0.0 " );
		} else {
			$ESME->{$system_id}->{'allowed_ip'} = $res->{'allowed_ip'};
		}

		unless ( defined( $res->{'bandwidth'} ) ) {
			$ESME->{$system_id}->{'bandwidth'} = 1;
			$this->log( "warning", "Setting bandwidth for $system_id to 1/s" );
		} else {
			$ESME->{$system_id}->{'bandwidth'} = $res->{'bandwidth'};
		}

		unless ( defined( $ESME->{$system_id}->{'received'} ) ) {
			$ESME->{$system_id}->{'received'} = 0;
		}

		unless ( defined( $ESME->{$system_id}->{'sent'} ) ) {
			$ESME->{$system_id}->{'sent'} = 0;
		}

		$this->_edr_write(
			{
				event_name    => 'Authentication',
				system_id     => $system_id,
				Status        => 'OK',
				cmd_status    => 0x0,
				src_addr_port => $addr_port,
			}
		);

		return 1;

	} else {

		# Try to find just system_id.

		my $sth = $this->authdbh->prepare( $this->conf->{auth}->{query_system_id} );
		my $rv  = $sth->execute($login);
		unless ( defined($rv) ) {
			$this->log( "warning", "Can't execute SQL " . $this->conf->{auth}->{query_system_id} . ". Trying to reconnect." );
			$this->_connect_db();
			$sth = $this->authdbh->prepare( $this->conf->{auth}->{query_system_id} );
			$rv  = $sth->execute($login);
			unless ( defined($rv) ) {
				return undef;
			}
		}

		# Try to get one row or return undef
		if ( my $res = $sth->fetchrow_hashref() ) {
			# If found - then password incorrect
			# else - system incorrect
			$this->_edr_write(
				{
					event_name    => 'Authentication',
					system_id     => $login,
					Status        => 'FAIL',
					src_addr_port => $addr_port,
					cmd_status    => 0x0E,
				}
			);
		} else {
			$this->_edr_write(
				{
					event_name    => 'Authentication',
					system_id     => $login,
					Status        => 'FAIL',
					src_addr_port => $addr_port,
					cmd_status    => 0x0F,
				}
			);
		}
		return undef;

	} ## end else [ if ( my $res = $sth->fetchrow_hashref...
} ## end sub _auth_esme

=item B<_increase_received> 

Increase received messages value 

=cut 

sub _increase_received {
	my ( $this, $connect_id ) = @_;

	$this->shm->lock(LOCK_EX);
	my $list = decode_json( $this->shm->fetch );
	unless ( defined ( $list->{$connect_id}->{'received'} ) ) { 
		$list->{$connect_id}->{'received'} = 1; 
	} else { 
		$list->{$connect_id}->{'received'} = $list->{$connect_id}->{'received'} + 1; 
	}
	$this->shm->store( encode_json($list) );
	$this->shm->unlock;

	my $login = $list->{$connect_id}->{'login'}; 
	$ESME->{$login}->{'received'}  = $ESME->{$login}->{'received'} + 1; 

}

=item B<_increase_sent> 

Increase sent messages value 

=cut 

sub _increase_sent {
	my ( $this, $connect_id ) = @_;

	$this->shm->lock(LOCK_EX);
	my $list = decode_json( $this->shm->fetch );
	unless ( defined ( $list->{$connect_id}->{'sent'} ) ) { 
		$list->{$connect_id}->{'sent'} = 1; 
	} else { 
		$list->{$connect_id}->{'sent'} = $list->{$connect_id}->{'sent'} + 1; 
	}
	$this->shm->store( encode_json($list) );
	$this->shm->unlock;

	my $login = $list->{$connect_id}->{'login'}; 
	$ESME->{$login}->{'sent'} = $ESME->{$login}->{'sent'} + 1;
	
}

=item B<_increase_already_connected> 

Tries to increase already_connected value for ESME. If it reaches the max_connections will return undef else return 1

=cut 

sub _increase_already_connected {

	my ( $this, $system_id ) = @_;

	my $new_connection_num = $ESME->{$system_id}->{'already_connected'} + 1;
	if ( $new_connection_num > $ESME->{$system_id}->{'max_connections'} ) {
		$this->log( "warning", "ESME \"$system_id\" reached maximum of connections. " );
		return undef;    # Do not authorize.

	}
	$ESME->{$system_id}->{'already_connected'} = $ESME->{$system_id}->{'already_connected'} + 1;
	$this->log( "info", "ESME \"$system_id\" already connected " . $ESME->{$system_id}->{'already_connected'} . " times" );

	return 1;

}

=item B<_decrease_already_connected> 

Decrease already connected value.

=cut 

sub _decrease_already_connected {

	my ( $this, $login ) = @_;

	unless ( defined( $ESME->{$login} ) ) {
		$this->log( "error", "Try to decrease already_connected for unexistent login $login" );
		return undef;
	}
	$ESME->{$login}->{'already_connected'} = $ESME->{$login}->{'already_connected'} - 1;
	if ( $ESME->{$login}->{'already_connected'} < 0 ) {
		$this->log( "error", "Decreased already_connected for $login < 0!" );
		$ESME->{$login}->{'already_connected'} = 0;
		return 1;
	}
	$this->log( "info", "Decrease already_connected for $login to " . $ESME->{$login}->{'already_connected'} );
	return 1;

} ## end sub _decrease_already_connected

sub _connect_db {

	my ($this) = @_;

	my $dsn    = $this->conf->{'auth'}->{'dsn'};
	my $user   = $this->conf->{'auth'}->{'db-user'};
	my $passwd = $this->conf->{'auth'}->{'db-password'};

	# If DBMS isn' t accessible - try reconnect
	if ( !$this->authdbh or !$this->authdbh->ping ) {
		$this->authdbh( DBI->connect_cached( $dsn, $user, $passwd ) );
	}

	if ( !$this->authdbh ) {
		$this->speak("Cant connect to DBMS!");
		$this->log( "error", "Cant connect to DBMS!" );
		return undef;
	}

	return 1;

} ## end sub _connect_db

=item B<_init_out_queue) 

Connects to socket of Mobile Terminated Queue Hadler. 

=cut 

sub _init_out_queue {

	my ( $this, %params ) = @_;

	use constant OUT_QUEUE_ADDR  => '127.0.0.1';
	use constant OUT_QUEUE_PORT  => '9999';
	use constant OUT_QUEUE_PROTO => 'tcp';

	my $out_queue_addr  = undef;
	my $out_queue_port  = undef;
	my $out_queue_proto = undef;

	unless ( defined( $this->conf->{'out_queue'}->{'addr'} ) ) {
		$out_queue_addr = OUT_QUEUE_ADDR;
	} else {
		$out_queue_addr = $this->conf->{'out_queue'}->{'addr'};
	}

	unless ( defined( $this->conf->{'out_queue'}->{'port'} ) ) {
		$out_queue_port = OUT_QUEUE_PORT;
	} else {
		$out_queue_port = $this->conf->{'out_queue'}->{'port'};
	}

	unless ( defined( $this->conf->{'out_queue'}->{'proto'} ) ) {
		$out_queue_proto = OUT_QUEUE_PROTO;
	} else {
		$out_queue_proto = $this->conf->{'out_queue'}->{'proto'};
	}

	# Connect to remote socket

	my $connect_failed = 0;

	out_queue_connect:

	$this->out_queue(
		IO::Socket::INET->new(
			PeerAddr => $out_queue_addr,
			PeerPort => $out_queue_port,
			Proto    => $out_queue_proto,
		)
	);

	unless ( defined( $this->out_queue ) ) {
		sleep(1);
		$connect_failed++;
		if ( $connect_failed > 5 ) {

			$this->log(
				"error",
				sprintf(
					"Cant connect to ougoing queue server at %s:%s/%s",
					$out_queue_addr,
					$out_queue_port,
					$out_queue_proto
				)
			);

			die(
				sprintf(
					"ERROR! Cant connect to outgoing queue server at %s:%s/%s",
					$out_queue_addr,
					$out_queue_port,
					$out_queue_proto
				)
			);
		} ## end if ( $connect_failed >...
		goto out_queue_connect;
	} ## end unless ( defined( $this->out_queue...

	$this->out_queue->autoflush(1);

	$this->log( "info", "Successfully connected to OUT Queue server" );

} ## end sub _init_out_queue

sub _init_in_queue {

	my ( $this, %params ) = @_;

	use constant IN_QUEUE_ADDR  => '127.0.0.1';
	use constant IN_QUEUE_PORT  => '9998';
	use constant IN_QUEUE_PROTO => 'tcp';

	my $in_queue_addr  = undef;
	my $in_queue_port  = undef;
	my $in_queue_proto = undef;

	unless ( defined( $this->conf->{'in_queue'}->{'addr'} ) ) {
		$in_queue_addr = IN_QUEUE_ADDR;
	} else {
		$in_queue_addr = $this->conf->{'in_queue'}->{'addr'};
	}

	unless ( defined( $this->conf->{'in_queue'}->{'port'} ) ) {
		$in_queue_port = IN_QUEUE_PORT;
	} else {
		$in_queue_port = $this->conf->{'in_queue'}->{'port'};
	}

	unless ( defined( $this->conf->{'in_queue'}->{'proto'} ) ) {
		$in_queue_proto = IN_QUEUE_PROTO;
	} else {
		$in_queue_proto = $this->conf->{'in_queue'}->{'proto'};
	}

	# Connect to remote socket

	my $connect_failed = 0;

	in_queue_connect:

	$this->in_queue(
		IO::Socket::INET->new(
			PeerAddr => $in_queue_addr,
			PeerPort => $in_queue_port,
			Proto    => $in_queue_proto,
		)
	);

	unless ( defined( $this->in_queue ) ) {
		sleep(1);
		$connect_failed++;
		if ( $connect_failed > 5 ) {

			$this->log(
				"error",
				sprintf(
					"Cant connect to incoming queue server at %s:%s/%s",
					$in_queue_addr,
					$in_queue_port,
					$in_queue_proto
				)
			);

			die(
				sprintf(
					"ERROR! Cant connect to incoming queue server at %s:%s/%s",
					$in_queue_addr,
					$in_queue_port,
					$in_queue_proto
				)
			);
		} ## end if ( $connect_failed >...
		goto in_queue_connect;
	} ## end unless ( defined( $this->in_queue...

	$this->in_queue->autoflush(1);

	$this->log( "info", "Successfully connected to INcoming Queue server" );

} ## end sub _init_in_queue

=itemB<_authorize_submit> 

Checks for allowed_src 

=cut 

sub _authorize_submit {

	my ( $this, $pdu, $hdl ) = @_;

	my $login = $hdl->{system_id};
	my $src   = $pdu->{source_addr};

	unless ( defined( $ESME->{$login}->{'allowed_src'} ) ) {
		# NULL in database
		return 1;
	}
	my @allowed_src = split( ',', $ESME->{$login}->{'allowed_src'} );

	foreach my $source (@allowed_src) {
		$source = str_trim($source);
		if ( $source eq $src ) {
			return 1;
		}
	}
	$this->_edr_write(
		{
			event_name    => 'cmd_submit_sm',
			system_id     => $login,
			Status        => 'FAIL',
			Cause         => 'Invalid source',
			src_addr_port => $src,
		}
	);

	$this->log( "warning", "Deny send SMS from '$src' for '$login'" );

	return undef;
} ## end sub _authorize_submit

sub _find_current_bandwidth_k {

	my ( $this, $login ) = @_;

	# Find sum of bandwidth of all connected users;
	my $s = 0;
	foreach my $system_id ( keys %$ESME ) {
		$s = $s + $ESME->{$system_id}->{'bandwidth'};
	}
	unless ( defined( $this->{conf}->{'throttle'}->{'bandwidth'} ) ) {
		return 1;    # global throttling not defined. Using unlimited.
	}
	my $global_band = $this->{conf}->{'throttle'}->{'bandwidth'};
	my $user_band   = $ESME->{$login}->{'bandwidth'};

	my $k = floor( $user_band * $global_band ) / $s;

	# Коэффициент глобального ограничения есть ( пользовательское ограничение * глобальное ) / ( сумму всех ограничение всех подключенных пользователей ) . Доказано RAD.

	return $k;

} ## end sub _find_current_bandwidth_k

=item B<_throttling> 

Check for count SMS in seconds 

=cut 

sub _throttling {

	my ( $this, $login ) = @_;
	my $new_message_timestamp = time();

	# If last_message_timestamp does not exist, accept;
	unless ( defined( $ESME->{$login}->{'last_message_timestamp'} ) ) {
		$ESME->{$login}->{'last_message_timestamp'} = time();
		return 1;
	}

	my $last_message_timestamp = $ESME->{$login}->{'last_message_timestamp'};
	my $difference             = $new_message_timestamp - $last_message_timestamp;

	if ( $difference > 0 ) {
		$ESME->{$login}->{'last_message_timestamp'}  = $new_message_timestamp;
		$ESME->{$login}->{'last_second_sm_received'} = 1;
		return 1;    # accept
	}

	if ( $difference < 0 ) {
		$ESME->{$login}->{'last_message_timestamp'}  = $new_message_timestamp;
		$ESME->{$login}->{'last_second_sm_received'} = 1;
		return 1;    # It's stupid error; accept;
	}

	# If difference  == 0; Count messages that was received while current timestamp
	unless ( defined( $ESME->{$login}->{'last_second_sm_received'} ) ) {
		$ESME->{$login}->{'last_second_sm_received'} = 0;
	}
	$ESME->{$login}->{'last_second_sm_received'} = $ESME->{$login}->{'last_second_sm_received'} + 1;

	# Local user bandwidth check
	if ( ( $ESME->{$login}->{'last_second_sm_received'} ) > $ESME->{$login}->{'bandwidth'} ) {
		return undef;    # Deny
	}

	my $k = 1000;

	# Caching global throttling check
	unless ( defined($throttle_timestamp) ) {
		$throttle_timestamp = time();
		$k                  = $this->_find_current_bandwidth_k($login);
	}
	$difference = $new_message_timestamp - $throttle_timestamp;

	if ( $difference > 60 ) {
		$k                  = $this->_find_current_bandwidth_k($login);
		$throttle_timestamp = $new_message_timestamp;
	}

	# Global system bandwidth check
	if ( ( $ESME->{$login}->{'last_second_sm_received'} + 1 ) > $k ) {
		$this->log( "warning", "Deny send SMS from $login for GLOBAL THROTTLING reason." );
		$this->speak("[$$] Deny send SMS from $login for GLOBAL THROTTLING reason.");
		$this->_edr_write(
			{
				event_name => 'Submit',
				system_id  => $login,
				Status     => 'FAIL',
				Reason     => 'GLOBAL THROTTLING'
			}
		);

		return undef;
	}

	return 1;    # accept

} ## end sub _throttling

=item B<cmd_submit_sm> 

We are replaced parent method because we need to sent message to IO::Socket::INET not MemcacheQ. 

=cut 

sub cmd_submit_sm {

	my ( $this, $pdu, $hdl ) = @_;

	my %COD_NAME = (
		0 => 'gsm0338',
		1 => '8bit',
		2 => 'ucs2',
	);

	my $resp_status = undef;          # response command status
	my $message_id  = make_uuid();    # message id on CPA (UUID style)

	my $utf8_text = '';               # message text in utf8 charset for EDR

	my $mode = $hdl->{'mode'};

	# Check if client is authenticated
	unless ( $hdl->{authenticated} ) {
		$resp_status = 0x45;
		goto SUBMIT_SM_RESP;
	}

	# FIXME - cache authorize
	my $is_auth = $this->_authorize_submit( $pdu, $hdl );
	unless ($is_auth) {
		$resp_status = 0x45;
		goto SUBMIT_SM_RESP;
	}

	if ( $mode eq 'receiver' ) {
		$resp_status = 0x45;
		goto SUBMIT_SM_RESP;
	}

	unless ( defined($resp_status) ) {
		# Throttling ?
		my $is_throttle = $this->_throttling( $hdl->{system_id} );

		unless ( defined($is_throttle) ) {

			$resp_status = 0x00000058;    # ESME_RTHROTTLED

			$hdl->{smpp}->submit_sm_resp(
				seq        => $pdu->{seq},
				status     => $resp_status,
				message_id => $message_id,
				async      => 1,
			);
			$this->_edr_write(
				{
					event_name    => 'cmd_submit_sm',
					system_id     => $hdl->{system_id},
					cmd_id        => 0x04,
					cmd_status    => $resp_status,
					message_id    => $message_id,
					seq           => $pdu->{seq},
					src_addr_port => $hdl->{id}
				}
			);
			goto SUBMIT_SM_RESP;

		} ## end unless ( defined($is_throttle...

		my $date_now = POSIX::strftime( "%Y-%m-%d %H:%M:%S", localtime );    #date_now();

		# Create empty message
		my $queue_msg = {
			client   => $hdl->{system_id},
			created  => $date_now,
			received => $date_now,
		};

		unless ( defined( $ESME->{ $hdl->{system_id} } ) ) {
			$queue_msg->{'esme_id'} = undef;

		} else {
			$queue_msg->{'esme_id'} = $ESME->{ $hdl->{system_id} }->{'esme_id'};
		}

		my $mclass = undef;    # default (ME specific according with GSM 03.38)

		# Create UUID for new MT message
		# $message_id = make_uuid();
		$queue_msg->{message_id} = $message_id;

		# Get source and destination addresses
		#	my $src_addr = $pdu->{source_addr};
		#   my $dst_addr = $pdu->{destination_addr};

		$queue_msg->{src_addr} = $pdu->{source_addr};
		$queue_msg->{dst_addr} = $pdu->{destination_addr};

		# **************************************************************************
		#
		# Process data_coding (see ETSI GSM 03.38 specification)
		#
		# Determine: message_class, coding, MWI flags
		#
		my $data_coding = $pdu->{data_coding};

		# Check if message_class is present
		if ( ( $data_coding & 0b00010000 ) eq 0b00010000 ) {
			$mclass = $data_coding & 0b00000011;
		}

		$queue_msg->{mclass} = $mclass;

		# Determine coding
		# Part.1: is this Latin1 (5.2.19 in SMPP v.3.4. spec. 0b00000011)
		#
		my $coding = 0;
		if ( ( $data_coding & 0b00000011 ) eq 0b00000011 ) {
			$coding = 3;    # Latin1 we are save in Database as 0b0011 ;)
		} else {
			$coding = ( $data_coding & 0b00001100 ) >> 2;
		}

		if ( $coding > 3 ) {
			$resp_status = 0x45;    # ESME_RSUBMITFAIL
			$this->log( "warning", "Unknown coding here. '$coding'" );
			goto SUBMIT_SM_RESP;
		}

		# Put it to message structure
		$queue_msg->{coding} = $coding;

		# Determine UDHI state
		my $udhi      = 0;                    # No UDH by default
		my $esm_class = $pdu->{esm_class};    # see 5.2.12 part of SMPP 3.4 spec
		if ( ( $esm_class & 0b01000000 ) eq 0b01000000 ) {
			$udhi = 1;
		}

		# **************************************************************************
		#
		# Process SM body (UD and UDH)
		#
		my $msg_text = $pdu->{short_message};
		# If have UDH, get if from message
		my $udh = undef;
		if ($udhi) {
			use bytes;
			my ($udhl) = unpack( "C*", bytes::substr( $msg_text, 0, 1 ) );
			$udh = bytes::substr( $msg_text, 0, $udhl + 1 );
			$msg_text = bytes::substr( $msg_text, $udhl + 1 );
			no bytes;
			$queue_msg->{udh} = conv_str_hex($udh);
		}

		# Convert text to UTF-8 for event logging
		$utf8_text = conv_gsm_utf8( $msg_text, $coding );
		$utf8_text = decode( 'utf-8', $utf8_text );    # Not byte, only Utf-8.

		# Put User Data (UD) to message structure
		$queue_msg->{body} = $msg_text;

		# Check if need DLR for message
		if ( $pdu->{registered_delivery} ) {
			$queue_msg->{register_delivery} = '1';
		}

		# Determine TTL for the message
		my $validity_period = $pdu->{validity_period};
		if ( $validity_period =~ /(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(\d)(\d\d)([\-\+R])/ ) {
			$queue_msg->{validity} = "20" . $1 . "-" . $2 . "-" . $3 . " " . $4 . ":" . $5 . ":" . $6;
		}

		# Determine deferred delivery time
		my $schedule_delivery_time = $pdu->{schedule_delivery_time};
		if ( $schedule_delivery_time =~ /(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(\d)(\d\d)([\-\+R])/ ) {
			$queue_msg->{deferred} = "20" . $1 . "-" . $2 . "-" . $3 . " " . $4 . ":" . $5 . ":" . $6;
		}

		# Determine priority
		if ( $pdu->{priority_flag} ) {
			$queue_msg->{priority} = $pdu->{priority_flag} + 0;
		}

		# Encoding queue_msg to JSON pretty
		# my $json_text = to_json( $queue_msg, { ascii => 1, pretty => 1 } );

		# Sending to IN Queue
		# my $res = $this->in_queue->print( conv_str_base64($json_text) . "\n" );
		#
		#$json_text = conv_str_base64($json_text)."\n";
		#
		#$resp_status = $this->_send_to_inq($json_text); # Around 50%;
		my $res = $this->{'plugindb'}->_put_mt($queue_msg);
		unless ( defined($res) ) {
			$resp_status = 0x45;
		} else {
			$resp_status = 0x00;
		}
	} ## end unless ( defined($resp_status...

	SUBMIT_SM_RESP:

	if ( $resp_status != 0x00 ) {

		$this->speak( "[$$] Submit fail from '" . $pdu->{source_addr} . "' to '" . $pdu->{destination_addr} . "' via '" . $hdl->{system_id} . "'" );
		$this->log( "warning", "Submit fail from '" . $pdu->{source_addr} . "' to '" . $pdu->{destination_addr} . "' via '" . $hdl->{system_id} . "'" );

		$this->_edr_write(
			{
				event_name    => 'cmd_submit_sm',
				system_id     => $hdl->{system_id},
				Status        => 'FAIL',
				cmd_id        => 0x04,
				cmd_status    => $resp_status,
				message_id    => $message_id,
				seq           => $pdu->{seq},
				src           => $pdu->{source_addr},
				dst           => $pdu->{destination_addr},
				text          => $utf8_text,
				src_addr_port => $hdl->{id},
			}
		);

	} ## end if ( $resp_status != 0x00)
	if ( $resp_status == 0x00 ) {

		$this->_edr_write(
			{
				event_name    => 'cmd_submit_sm',
				system_id     => $hdl->{system_id},
				Status        => 'OK',
				cmd_id        => 0x04,
				cmd_status    => $resp_status,
				message_id    => $message_id,
				seq           => $pdu->{seq},
				src           => $pdu->{source_addr},
				dst           => $pdu->{destination_addr},
				text          => $utf8_text,
				src_addr_port => $hdl->{id},
			}
		);

		#FIXME: cache this!
		$this->_increase_received( $hdl->{id} );

	} ## end if ( $resp_status == 0x00)

	# Send response to ESME
	# Note: we use asynchronous sending to avoid deadlocks
	$hdl->{smpp}->submit_sm_resp(
		seq        => $pdu->{seq},
		status     => $resp_status,
		message_id => $message_id,
		async      => 1,
	);

} ## end sub cmd_submit_sm

sub _send_to_inq {
	my $this         = shift;
	my $json_text    = shift;
	my $input_socket = $this->{socket_in_queue};
	my $resp_status  = undef;

	my $res = print $input_socket $json_text;
	if ( !$res ) {
		$resp_status = 0x45;    # ESME_RSUBMITFAIL
	}

	my $confirm = <$input_socket>;
	if ( $confirm =~ /OK/ ) {
		$resp_status = 0x00;
	} else {
		$resp_status = 0x45;
	}

	return $resp_status;
} ## end sub _send_to_inq

sub cmd_unbind {

	my ( $this, $pdu, $hdl ) = @_;

	# warn "[$$] ". Dumper ($pdu);
	my $system_id = $hdl->{system_id};

	my $resp = $hdl->{smpp}->unbind_resp(
		seq    => $pdu->{seq},
		status => $pdu->{status},
	);

	# decrease already connected value for system_id
	$this->_decrease_already_connected( $hdl->{system_id} );

	# Update SHM struture (only for defined system_id)
	if ( $hdl->{system_id} ) {
		if ( $ESME->{$system_id}->{'already_connected'} <= 0 ) {
			# If it was last connect, remove ESME from SHM
			$this->shm->lock(LOCK_EX);
			my $list = decode_json( $this->shm->fetch );
			delete $list->{ $hdl->{id} };
			$this->shm->store( encode_json($list) );
			$this->shm->unlock;
		} else {
			# ELSE Just decrease already_connected value in SHM
			$this->shm->lock(LOCK_EX);
			my $list = decode_json( $this->shm->fetch );
			$list->{ $hdl->{id} }->{'already_connected'} = $ESME->{$system_id}->{'already_connected'};
			$this->shm->store( encode_json($list) );
			$this->shm->unlock;
		}
	}

	# Remove socket from select()
	$this->selector->remove( $hdl->{smpp} );

	# Close socket and remove record
	$hdl->{smpp}->close();
	delete $this->{handlers}->{ $hdl->{id} };

	$this->_edr_write(
		{
			event_name    => 'cmd_unbind',
			system_id     => $hdl->{system_id},
			src_addr_port => $hdl->{id},
			cmd_status    => 0x00,
			cmd_id        => 0x06,
		}
	);

}    # end sub cmd unbind

=item B<_acl_source_ip> 

Check allowed_ip field for peer host src ip. 

=cut 

sub _acl_source_ip {

	my ( $this, $login, $peer ) = @_;

	if ( $ESME->{$login}->{'allowed_ip'} eq '0.0.0.0' ) {
		$this->log( "warning", "Allowed src ip for $login is anywhere (0.0.0.0). OK." );
		$this->speak("[$$] Allowed src ip for $login is anywhere (0.0.0.0). OK.");
		return 1;
	}

	my ( $peerhost, $peerport ) = split( ':', $peer );

	my (@allowed) = split( ',', $ESME->{$login}->{'allowed_ip'} );

	$this->log( "info", $login . ": peer : '" . $peerhost . "' : allowed : '" . $ESME->{$login}->{'allowed_ip'} . "'" );
	$this->speak( "[$$] $login: peer : '" . $peerhost . "' : allowed : '" . $ESME->{$login}->{'allowed_ip'} . "'" );

	foreach my $host (@allowed) {
		$host = str_trim($host);
		if ( $host eq $peerhost ) {
			$this->log( "info", $login . " allow from " . $peerhost );
			$this->speak( "[$$] $login  allow from " . $peerhost );
			return 1;
		}
	}
	$this->log( "warning", $login . " deny from " . $peerhost );
	$this->speak("[$$] $login deny from $peerhost");

	return undef;

} ## end sub _acl_source_ip

sub _authorize_esme {

	my ( $this, $login, $hdl ) = @_;

	my $resp_status = 0x00000000;

	unless ( defined( $this->_acl_source_ip( $login, $hdl->{id} ) ) ) {
		return 0x0000000F;    # ESME_RINVSYSID
	}

	unless ( defined( $this->_increase_already_connected($login) ) ) {
		return 0x0000000D;    # ESME_RBINDFAIL
	}

	return 0x00000000;        # OK
}

#
# bind_transiever called when ESME connect to us in transiever mode (send and receive SMS in one connection )
#

sub cmd_bind_transceiver {

	my ( $this, $pdu, $hdl ) = @_;

	# Determine incoming login (system-id) and password
	my $login  = $pdu->{system_id};
	my $passwd = $pdu->{password};

	my $resp_status = 0x00000000;    # All OK

	# Send error status if already authenticated
	if ( $hdl->{authenticated} ) {
		$this->speak("[$$] Already binded ESME authentication: $login");
		$this->log( "warning", "Already binded ESME authentication: $login" );

		if ( $this->_increase_already_connected($login) ) {
			$resp_status = 0x00000005;    # Already in bind state
		} else {
			$resp_status = 0x0000000E;    # Do not authorize
		}

	} else {

		# Authentication. ID contains IP:PORT value
		if ( $this->_auth_esme( $login, $passwd, $hdl->{'id'} ) ) {
			$this->log( "info", "ESME '$login' successfully authenticated" );
			$resp_status = $this->_authorize_esme( $login, $hdl );
			if ( $resp_status == 0x00 ) {

				# Update handlers
				$this->{handlers}->{ $hdl->{id} }->{authenticated} = 1;
				$this->{handlers}->{ $hdl->{id} }->{system_id}     = $login;
				$this->{handlers}->{ $hdl->{id} }->{mode}          = 'transceiver';

				# Update SHM struture
				my $list = decode_json( $this->shm->fetch );
				my $connect_id = $hdl->{id}; 

				$list->{$connect_id}->{'esme_id'}           = $ESME->{$login}->{'esme_id'};
				$list->{$connect_id}->{'mode'}              = 'transciever';
				$list->{$connect_id}->{'bandwidth'}         = $ESME->{$login}->{'bandwidth'};
				$list->{$connect_id}->{'already_connected'} = $ESME->{$login}->{'already_connected'};
				$list->{$connect_id}->{'sent'}              = $ESME->{$login}->{'sent'};
				$list->{$connect_id}->{'received'}          = $ESME->{$login}->{'received'};
				$list->{$connect_id}->{'login'}        = $login; 

				$this->shm->lock(LOCK_EX);
				$this->shm->store( encode_json($list) );
				$this->shm->unlock;
			} ## end if ( $resp_status == 0x00)

		} else {
			$this->log( "warning", "Cant authenticate ESME: [$login:$passwd]" );
			$this->speak("Cant authenticate ESME: [$login:$passwd]");
			$resp_status = 0x0000000E;    # ESME_RINVPASWD

			# Send ESME_RINVPASWD
			my $resp = $hdl->{smpp}->bind_transceiver_resp(
				seq       => $pdu->{seq},
				status    => $resp_status,
				system_id => $LOCAL_SYSTEM_ID,
			);

			# Close socket
			# Remove socket from select()
			$this->selector->remove( $hdl->{smpp} );

			# Close socket and remove record
			$hdl->{smpp}->close();
			#undef $this->{handlers}->{ $hdl->{id} };
			delete $this->{handlers}->{ $hdl->{id} };

		} ## end else [ if ( $this->_auth_esme...
	} ## end else [ if ( $hdl->{authenticated...

	my $status = undef;

	if ( $resp_status == 0x00 ) {
		$status = 'OK';
	} else {
		$status = 'FAIL';
	}

	$this->_edr_write(
		{
			event_name    => 'cmd_bind_transciever',
			system_id     => $login,
			Status        => $status,
			cmd_id        => 0x09,
			cmd_status    => $resp_status,
			src_addr_port => $hdl->{id},
		}
	);

	my $resp = $hdl->{smpp}->bind_transceiver_resp(
		seq       => $pdu->{seq},
		status    => $resp_status,       # ESME_ROK
		system_id => $LOCAL_SYSTEM_ID,
	);

} ## end sub cmd_bind_transceiver

sub cmd_bind_transmitter {

	my ( $this, $pdu, $hdl ) = @_;

	# Determine incoming login (system-id) and password
	my $login  = $pdu->{system_id};
	my $passwd = $pdu->{password};

	my $resp_status = 0x00000000;    # All OK

	# Send error status if already authenticated
	if ( $hdl->{authenticated} ) {

		$this->log( "warning", "Already binded ESME authentication: $login" );
		$this->speak("[$$] Already binded ESME authentication: $login");
		if ( $this->_increase_already_connected($login) ) {
			$resp_status = 0x00000005;    # Already in bind state
		} else {
			$resp_status = 0x0000000E;    # Do not authorize
		}

	} else {

		# Authentication
		if ( $this->_auth_esme( $login, $passwd, $hdl->{'id'} ) ) {
			$this->speak("[$$] ESME '$login' successfully authenticated");
			$this->log( "info", "ESME '$login' successfully authenticated" );
			$resp_status = $this->_authorize_esme( $login, $hdl );
			if ( $resp_status == 0x00 ) {

				# Update handlers
				$this->{handlers}->{ $hdl->{id} }->{authenticated} = 1;
				$this->{handlers}->{ $hdl->{id} }->{system_id}     = $login;
				$this->{handlers}->{ $hdl->{id} }->{mode}          = 'transmitter';

				# Update SHM struture
				my $list = decode_json( $this->shm->fetch );
				my $connect_id = $hdl->{id}; 

				$list->{$connect_id}->{'login'}             = $login; 
				$list->{$connect_id}->{'esme_id'}           = $ESME->{$login}->{'esme_id'};
				$list->{$connect_id}->{'mode'}              = 'transmitter';
				$list->{$connect_id}->{'bandwidth'}         = $ESME->{$login}->{'bandwidth'};
				$list->{$connect_id}->{'already_connected'} = $ESME->{$login}->{'already_connected'};
				$list->{$connect_id}->{'sent'}              = $ESME->{$login}->{'sent'};
				$list->{$connect_id}->{'received'}          = $ESME->{$login}->{'received'};

				$this->shm->lock(LOCK_EX);
				$this->shm->store( encode_json($list) );
				$this->shm->unlock;

			} ## end if ( $resp_status == 0x00)

		} else {
			$this->log( "warning", "Cant authenticate ESME: [$login:$passwd]" );
			$this->speak("Cant authenticate ESME: [$login:$passwd]");
			$resp_status = 0x0000000E;    # ESME_RINVPASWD
			my $resp = $hdl->{smpp}->bind_transmitter_resp(
				seq       => $pdu->{seq},
				status    => $resp_status,       # ESME_RINVPASWD
				system_id => $LOCAL_SYSTEM_ID,
			);
			# Close socket
			# Remove socket from select()
			$this->selector->remove( $hdl->{smpp} );

			# Close socket and remove record
			$hdl->{smpp}->close();
			delete $this->{handlers}->{ $hdl->{id} };
			# undef $this->{handlers}->{ $hdl->{id} };

		}
	} ## end else [ if ( $hdl->{authenticated...

	my $status = undef;
	if ( $resp_status == 0x00 ) {
		$status = 'OK';
	} else {
		$status = 'FAIL';
	}
	$this->_edr_write(
		{
			event_name    => 'cmd_bind_transmitter',
			system_id     => $login,
			Status        => $status,
			cmd_id        => 0x02,
			cmd_status    => $resp_status,
			src_addr_port => $hdl->{id},

		}
	);

	my $resp = $hdl->{smpp}->bind_transmitter_resp(
		seq       => $pdu->{seq},
		status    => $resp_status,       # ESME_ROK
		system_id => $LOCAL_SYSTEM_ID,
	);

} ## end sub cmd_bind_transmitter

sub cmd_bind_receiver {

	my ( $this, $pdu, $hdl ) = @_;

	# Determine incoming login (system-id) and password
	my $login  = $pdu->{system_id};
	my $passwd = $pdu->{password};

	my $resp_status = 0x00000000;    # All OK

	# Send error status if already authenticated
	if ( $hdl->{authenticated} ) {

		$this->log( "warning", "Already binded ESME authentication: $login" );
		if ( $this->_increase_already_connected($login) ) {
			$resp_status = 0x00000005;    # Already in bind state
		} else {
			$resp_status = 0x0000000E;    # Do not authorize
		}

	} else {

		# Authentication
		if ( $this->_auth_esme( $login, $passwd, $hdl->{'id'} ) ) {
			$this->speak("ESME '$login' successfully authenticated");
			$this->log( "info", "ESME '$login' successfully authenticated" );
			$resp_status = $this->_authorize_esme( $login, $hdl );
			if ( $resp_status == 0x00 ) {

				# Update handlers
				$this->{handlers}->{ $hdl->{id} }->{authenticated} = 1;
				$this->{handlers}->{ $hdl->{id} }->{system_id}     = $login;
				$this->{handlers}->{ $hdl->{id} }->{mode}          = 'receiver';

				# Update SHM struture
				my $list = decode_json( $this->shm->fetch );
				my $connect_id = $hdl->{id}; 

				$list->{$connect_id}->{'login'} = $login; 
				$list->{$connecy_id}->{'esme_id'}           = $ESME->{$login}->{'esme_id'};
				$list->{$connect_id}->{'mode'}              = 'receiver';
				$list->{$connect_id}->{'bandwidth'}         = $ESME->{$login}->{'bandwidth'};
				$list->{$connect_id}->{'already_connected'} = $ESME->{$login}->{'already_connected'};
				$list->{$connect_id}->{'sent'}              = $ESME->{$login}->{'sent'};
				$list->{$connect_id}->{'received'}          = $ESME->{$login}->{'received'};

				$this->shm->lock(LOCK_EX);
				$this->shm->store( encode_json($list) );
				$this->shm->unlock;
			} ## end if ( $resp_status == 0x00)

		} else {
			$this->log( "warning", "Cant authenticate ESME: [$login:$passwd]" );
			$this->speak("Cant authenticate ESME: [$login:$passwd]");
			$resp_status = 0x0000000E;    # ESME_RINVPASWD

			my $resp = $hdl->{smpp}->bind_receiver_resp(
				seq       => $pdu->{seq},
				status    => $resp_status,       # ESME_RINVPASWD
				system_id => $LOCAL_SYSTEM_ID,
			);

			# Close socket
			# Remove socket from select()
			$this->selector->remove( $hdl->{smpp} );

			# Close socket and remove record
			$hdl->{smpp}->close();
			#undef $this->{handlers}->{ $hdl->{id} };
			delete $this->{handlers}->{ $hdl->{id} };

		} ## end else [ if ( $this->_auth_esme...
	} ## end else [ if ( $hdl->{authenticated...

	my $status = undef;
	if ( $resp_status == 0x00 ) {
		$status = 'OK';
	} else {
		$status = 'FAIL';
	}
	$this->_edr_write(
		{
			event_name    => 'cmd_bind_receiver',
			system_id     => $login,
			Status        => $status,
			cmd_id        => 0x01,
			cmd_status    => $resp_status,
			src_addr_port => $hdl->{id},
		}
	);

	my $resp = $hdl->{smpp}->bind_receiver_resp(
		seq       => $pdu->{seq},
		status    => $resp_status,       # ESME_ROK
		system_id => $LOCAL_SYSTEM_ID,
	);

} ## end sub cmd_bind_receiver

sub _process_out_queue {
	my ( $this, %params ) = @_;

	my $output_socket = $this->{'socket_out_queue'};

	# Try to get next line from Queue server over TCP socket
	my $line = <$output_socket>;
	unless ( defined($line) ) {
		return undef;
	}
	# Return if keepalive
	if ( $line =~ '-MARK-' ) {
		$this->speak("Keepalive from queue server");
		return 1;
	}

	my $mo = decode_json( conv_base64_str($line) );

	$this->log( "info", "got SM from OutQ:" . Dumper($mo) ) if ( $this->{debug} );

	# Check if exist in MO esme_id
	unless ( defined( $mo->{'esme_id'} ) ) {
		$this->speak("[$$] MO with empty esme_id");
		$this->log( "warning", "MO with empty esme_id" );
	} else {
		# esme_id is not empty, searching system_id and socket
		foreach my $esme ( keys %$ESME ) {
			unless ( defined( $ESME->{$esme}->{'esme_id'} ) ) { next; }
			if ( $ESME->{$esme}->{'esme_id'} eq $mo->{'esme_id'} ) {
				$mo->{'system_id'} = $esme;
				last;
			}
		}

		unless ( defined( $mo->{'system_id'} ) ) {
			# ESME was not connected from server start.
			# Information about it not found in our memory.
			# Situation: Not connected. Return ERROR.
			$this->log( "info", "ESME with ID # " . $mo->{'esme_id'} . " was not connected yet." );
			print $output_socket "ERROR\n";
			return undef;

		}
		# Looking for proper ESME connect
		my $esme_connect_found = 0;
		my @esme_connects      = ();

		foreach my $hdl ( values %{ $this->handlers } ) {
			unless ( defined( $hdl->{system_id} ) ) { next; }
			if ( $hdl->{system_id} eq $mo->{'system_id'} ) {
				if ( ( $hdl->{mode} eq 'transceiver' ) or ( $hdl->{mode} eq 'receiver' ) ) {
					# Found connect. Push IT.
					push @esme_connects, $hdl;
					$esme_connect_found = $esme_connect_found + 1;
				}
			}
		}

		if ( $esme_connect_found <= 0 ) {
			$this->speak( "[$$] ESME " . $mo->{'system_id'} . "not found in active list. " );
			$this->log( "warning", "ESME " . $mo->{'system_id'} . "not found in active list. " );
			print $output_socket "ERROR\n";
		} else {
			my $hdl_index = rand($esme_connect_found);          # Select random connect
			my $hdl       = $esme_connects[$hdl_index];
			my $dlvrd     = $this->_deliver_sm( $hdl, $mo );    # send deliver_sm to ESME
			unless ( defined($dlvrd) ) {
				print $output_socket "ERROR\n";
			} else {
				print $output_socket "OK\n";
			}
		}

	} ## end else

} ## end sub _process_out_queue

sub _deliver_sm {

	my ( $this, $hdl, $mo ) = @_;

	if ( $mo->{id} ) {

		# Set default parameters (for MO SM)
		my $message_id       = $mo->{id};
		my $esm_class        = $mo->{mclass};
		my $source_addr_ton  = 0x01;
		my $source_addr_npi  = 0x01;
		my $source_addr      = $mo->{src_addr};
		my $dest_addr_ton    = 0x00;
		my $dest_addr_npi    = 0x01;
		my $destination_addr = $mo->{dst_addr};
		my $msg_text         = $mo->{text};

		# Set right data_coding field.

		my $data_coding = $mo->{coding};
		if ( $data_coding < 3 ) {
			$data_coding = ( $data_coding << 2 ) & 0b00001100;
		}

		my $system_id = $hdl->{system_id};
		$this->log( "info", "Deliver SM from '$source_addr' to '$destination_addr' via '$system_id'" );
		$this->log( "info", "MO Dump: " . Dumper($mo) );

		# Send deliver_sm
		if (    ( $esm_class == 4 )
			and ( defined( $mo->{message_state} ) )
			and ( defined( $mo->{receipted_message_id} ) ) )
		{    # DLR
			$hdl->{smpp}->deliver_sm(
				source_addr_ton      => $source_addr_ton,             # International (MSISDN)
				source_addr_npi      => $source_addr_npi,             # E.164
				source_addr          => $source_addr,
				dest_addr_ton        => $dest_addr_ton,               # Unknown (default)
				dest_addr_npi        => $dest_addr_npi,               # E.164
				destination_addr     => $destination_addr,
				esm_class            => $esm_class,                   # MO data (UDH + UD) or DLR
				short_message        => $msg_text,
				async                => 1,
				data_coding          => $data_coding,
				message_state        => $mo->{message_state},
				receipted_message_id => $mo->{receipted_message_id}
			);
		} else {

			$hdl->{smpp}->deliver_sm(
				source_addr_ton  => $source_addr_ton,                 # International (MSISDN)
				source_addr_npi  => $source_addr_npi,                 # E.164
				source_addr      => $source_addr,
				dest_addr_ton    => $dest_addr_ton,                   # Unknown (default)
				dest_addr_npi    => $dest_addr_npi,                   # E.164
				destination_addr => $destination_addr,
				esm_class        => $esm_class,                       # MO data (UDH + UD) or DLR
				short_message    => $msg_text,
				async            => 1,
				data_coding      => $data_coding,
			);

		}

		$hdl->{out_seq}++;
		$this->_edr_write(
			{
				event_name    => 'cmd_deliver_sm',
				cmd_id        => 0x05,
				cmd_status    => 0x00,
				system_id     => $hdl->{system_id},
				Status        => 'OK',
				src_addr_port => $hdl->{id},
				src           => $source_addr,
				dst           => $destination_addr,
				text          => $msg_text,
				message_id    => $mo->{id},
			}
		);

		$this->_increase_sent( $hdl->{id} );
		return 1;
	} ## end if ( $mo->{id} )

	$this->log( "warning", "MO/DLR does not have Message-ID." );
	$this->log( "info",    Dumper($mo) );

	return undef;

} ## end sub _deliver_sm

sub _process_socket {
	my ( $this, $hdl ) = @_;

	# Determine peer IP and port
	my $peer_addr = $hdl->{smpp}->peerhost;
	my $peer_port = $hdl->{smpp}->peerport;

	# Try to read PDU
	my $pdu = $hdl->{smpp}->read_pdu();

	if ( !$pdu ) {

		# Disconnect if EOF
		if ( $hdl->{smpp}->eof() ) {

			$this->speak("[$$] EOF from ${peer_addr}:${peer_port}");
			$this->log( "warning", "EOF from ${peer_addr}:${peer_port}" );

			if ( $hdl->{system_id} ) {
				$this->_decrease_already_connected( $hdl->{system_id} );
			}

			# Remove socket from select()
			$this->selector->remove( $hdl->{smpp} );

			# Close socket and remove record
			$hdl->{smpp}->close();
			delete $this->{handlers}->{ $hdl->{id} };

			my $login = $hdl->{system_id};
			# Update SHM struture (only for defined system_id)
			if ( $hdl->{system_id} ) {
				if ( $ESME->{$login}->{'already_connected'} <= 0 ) {
					# Если это был последний коннект, то удаляем структуру из памяти. Нечего занимать. 
					$this->shm->lock(LOCK_EX);
					my $list = decode_json( $this->shm->fetch );
					delete $list->{ $hdl->{id} };
					$this->shm->store( encode_json($list) );
					$this->shm->unlock;
				} else {
					$this->shm->lock(LOCK_EX);
					my $list = decode_json( $this->shm->fetch );
					$list->{$id}->{'already_connected'} = $ESME->{$login}->{'already_connected'};
					$this->shm->store( encode_json($list) );
					$this->shm->unlock;
				}
			}

		} else {

			$this->speak("[$$] Incoming event arrived but no SMPP PDU!");
			$this->log( "warning", "Incoming event arrived from [${peer_addr}:${peer_port}] but no SMPP PDU!" );
		}

	} else {

		# Process incoming PDU
		my $pdu_cmd = "unknown";
		if ( cmd_tab->{ $pdu->{cmd} } ) {
			$pdu_cmd = cmd_tab->{ $pdu->{cmd} };
		}

		# $this->log("info", "PDU arrived: $pdu_cmd");

		# Determine method name to dispatch PDU call
		my $method_name = "cmd_" . $pdu_cmd;

		if ( $pdu_cmd eq 'enquire_link' ) {

			# process enqiure_link locally
			$this->cmd_enquire_link( $pdu, $hdl );

		} elsif ( ( $pdu_cmd =~ /^bind_(transceiver|transmitter|receiver)/ ) and $this->can($method_name) ) {

			# Process known authentication methods
			$this->$method_name( $pdu, $hdl );

		} elsif ( $this->can($method_name) and $hdl->{authenticated} ) {

			# process known PDUs
			$this->$method_name( $pdu, $hdl );

		} else {

			# PDU unknown - damn it
			$this->cmd_unknown( $pdu, $hdl );

		}

	} ## end else [ if ( !$pdu )

} ## end sub _process_socket

sub _kick {
	my $this = shift;

	my $list = decode_json( $this->shm->fetch );
	foreach my $connect_id ( keys %$list ) {
		if ( defined( $list->{$connect_id}->{'kick'} ) ) {
			my $login = $list->{$connect_id}->{'login'}; 
			$this->_shutup($login);
		}
	}
}

sub _reload {
	my $this = shift;

}

sub _shutup {
	my ( $this, $login ) = @_;

	foreach my $hdl ( values %{ $this->handlers } ) {
		my $system_id = $hdl->{'system_id'};
		if ( $system_id eq $login ) {
			my $seq = $hdl->{smpp}->unbind();
		}
	}
}

sub main_loop {

	my ( $this, %params ) = @_;

	# Run user defined hooks on startup
	$this->start();

	# Run main process loop
	while ( !$this->{to_finalize} ) {

		# Wait for incoming events on all sockets
		my ( $sel_r, $sel_w, $sel_x ) = IO::Select->select( $this->selector, undef, undef, 0.0005 );

		# Go through available for reading sockets
		if ( $sel_r and my @readers = @{$sel_r} ) {

			# Check all sockets ready for reading
			foreach my $reader (@readers) {

				no warnings 'uninitialized';

				#			warn Dumper (\@readers);
				#warn Dumper ($this->out_queue);
				if ( $reader eq $this->listener ) {

					# Process incoming connection
					$this->_accept_incoming();

				} elsif ( $reader eq $this->{'socket_out_queue'} ) {

					# Process ougoing queue
					$this->_process_out_queue();

				} else {

					# Process events from established SMPP connection
					foreach my $hdl_key ( keys %{ $this->handlers } ) {
						if ( $this->handlers->{$hdl_key} and ( $this->handlers->{$hdl_key}->{smpp} eq $reader ) ) {
							$this->_process_socket( $this->handlers->{$hdl_key} );
						}
					}

				}
				;    ## end if ( $reader eq $this->listener )

				use warnings 'all';

			} ## end foreach my $reader (@readers)

		} ## end if ( $sel_r and my @readers...

	} ## end while ( !$this->{to_finalize...

	# Run user defined hooks on shutdown
	$this->stop();

} ## end sub main_loop

1;
#===============================================================================

__END__

=head1 NAME

smppd.pl

=head1 SYNOPSIS

smppd.pl

=head1 DESCRIPTION

FIXME

=head1 EXAMPLES

FIXME

=head1 BUGS

Unknown.

=head1 TODO

Empty.

=head1 AUTHOR

Michael Bochkaryov <misha@rattler.kiev.ua>
Alex Radetsky <rad@rad.kiev.ua>


=cut

