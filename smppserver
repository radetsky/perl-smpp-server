#!/usr/bin/env perl 
#===============================================================================
#
#         FILE:  smppd.pl
#
#        USAGE:  ./smppd.pl
#
#  DESCRIPTION:  NetSDS SMPP Server
#
#      OPTIONS:  ---
# REQUIREMENTS:
#         BUGS:  ---
#        NOTES:  ---
#       AUTHOR:  Michael Bochkaryov (Rattler), <misha@rattler.kiev.ua>
#      COMPANY:  Net.Style
#      VERSION:  1.0
#      CREATED:  12.07.2009 15:15:03 UTC
#     REVISION:  ---
#     MODIFIED:  Alex Radetsky (rad), <rad@rad.kiev.ua>
#===============================================================================

use 5.8.0;
use strict;
use warnings;

SMPPServerV2->run(
	daemon      => undef,
	verbose     => 1,
	use_pidfile => 1,
	has_conf    => 1,
	debug       => 1,
	conf_file   => "./smppserver.conf",
#	edr_file    => "./log/events.log",
);

1;

package SMPPServerV2;

use 5.8.0;
use strict;
use warnings;

use base qw(NetSDS::App::SMPPServer);

use NetSDS::Util::Convert;
use NetSDS::Util::DateTime;
use NetSDS::Util::String;
use NetSDS::Util::Misc;
use NetSDS::Queue;
use NetSDS::App::SMSTradeOutQ;
use NetSDS::App::SMSTradeInQ;
use IPC::ShareLite qw ( :lock );
use JSON;
use DBI;
use Time::HiRes qw(usleep);
use Data::Dumper;
use POSIX qw(floor);

# SMPP PDU command_id table
use constant cmd_tab => {
	0x80000000 => 'generic_nack',
	0x00000001 => 'bind_receiver',
	0x80000001 => 'bind_receiver_resp',
	0x00000002 => 'bind_transmitter',
	0x80000002 => 'bind_transmitter_resp',
	0x00000003 => 'query_sm',
	0x80000003 => 'query_sm_resp',
	0x00000004 => 'submit_sm',
	0x80000004 => 'submit_sm_resp',
	0x80000005 => 'deliver_sm_resp',
	0x00000006 => 'unbind',
	0x80000006 => 'unbind_resp',
	0x00000007 => 'replace_sm',
	0x80000007 => 'replace_sm_resp',
	0x00000008 => 'cancel_sm',
	0x80000008 => 'cancel_sm_resp',
	0x00000009 => 'bind_transceiver',
	0x80000009 => 'bind_transceiver_resp',
	0x0000000b => 'outbind',
	0x00000015 => 'enquire_link',
	0x80000015 => 'enquire_link_resp',
};

my @CHILDREN = array();
my $ESME     = undef;

sub initialize {

	my ( $this, %params ) = @_;

	$this->speak("[$$] SMPPServerV2 Initializing application.");
	# Determine application name from process name
	if ( !$this->{name} ) {
		$this->_determine_name();
	}

	# Get CLI parameters
	$this->_get_cli_param();

	# Create syslog handler
	if ( !$this->logger ) {
		$this->logger( NetSDS::Logger->new( name => $this->{name} ) );
		$this->log( "info", "Logger started" );
	}

	# Initialize configuration
	if ( $this->{has_conf} ) {

		# Automatically determine configuration file name
		if ( !$this->{conf_file} ) {
			$this->{conf_file} = $this->config_file( $this->{name} . ".conf" );
		}

		# Get configuration file
		if ( my $conf = NetSDS::Conf->getconf( $this->{conf_file} ) ) {
			$this->conf($conf);
			$this->log( "info", "Configuration file read OK: " . $this->{conf_file} );
		} else {
			$this->log( "error", "Can't read configuration file: " . $this->{conf_file} );
		}

		# Add automatic features
		if ( $this->auto_features ) {
			$this->use_auto_features();
		}

	} ## end if ( $this->{has_conf})

	# Initialize EDR writer
	if ( defined ( $this->{conf}->{'event_log'}->{'edr_file'} ) ) {
		$this->{edr_writer} = NetSDS::EDR->new( filename => $this->{conf}->{'event_log'}->{'edr_file'} );
	}

	# Daemonize, if needed
	if ( $this->daemon() ) {
		$this->speak("[$$] Daemonize, switch verbosity to false.");
		$this->{verbose} = undef;
		Proc::Daemon::Init;
	}

	# Process PID file if necessary
	if ( $this->use_pidfile ) {
		if ( Proc::PID::File->running( dir => $this->pid_dir, name => $this->{name} ) ) {
			$this->log( "error", "Application already running, stop immediately!" );
			die "Application already running, stop immediately!";
		}
	}

	# Update PID if necessary
	$this->{pid} = $$;

	$this->_burn_children();

	# Add signal handlers
	$SIG{INT} = sub {
		$this->speak("SIGINT caught");
		$this->log( "warn", "SIGINT caught" );
		my $perm = kill "TERM" => @CHILDREN;
		$this->speak("Sent TERM to $perm processes");
		$this->{to_finalize} = 1;
	};

	$SIG{TERM} = sub {
		$this->speak("SIGTERM caught");
		$this->log( "warn", "SIGTERM caught" );
		my $perm = kill "TERM" => @CHILDREN;
		$this->speak("Sent TERM to $perm processes");
		$this->{to_finalize} = 1;
	};
	$SIG{USR1} = sub {
		$this->speak("SIGUSR1 caught");
		$this->log( "info", "SIGUSR1 caught" );
		$this->_kick();      # Seek and destrou
		$this->_reload();    # Reload users configuration

	};
	# Initialize signals processing
	# $this->set_signal_processors();

	# Create select() handler for incoming events
	$this->selector( IO::Select->new() );

	# Initialize queue listener for outgoing events
	$this->_init_out_queue();
	$this->selector->add( $this->out_queue );

	# Initialize queue for incoming (MT) events
	$this->_init_in_queue();

	# Initialize listening socket and add to select()
	$this->_init_listener();
	$this->selector->add( $this->listener );

	# Set initial empty array of handlers hashref
	$this->handlers( {} );

	# Initialize SHM area
	$this->_init_shm();

} ## end sub initialize

sub _edr_write {
	my ( $this, $params ) = @_;

	unless ( defined( $this->{conf}->{'event_log'}->{'edr_file'} ) ) {
		return undef;
	}

	$params->{'timestamp'} = date_now();

	$this->{edr_writer}->write($params);

}

sub _burn_children {

	my ( $this, %params ) = @_;

	# Out Q
	$this->speak("[$$] Forking Outgoing Queue Plugin");
	my $pid = fork();
	unless ( defined($pid) ) {
		die "[$$] Fork() for Outgoing Queue Plugin failed: $!";
	}
	if ( $pid == 0 ) {
		$this->speak("[$$] Running NetSDS::App::SMSTradeOutQ");
		my $smsout = new NetSDS::App::SMSTradeOutQ();
		$smsout->{conf} = $this->{conf};
		$smsout->run();
		die "[$$] NetSDS::App::SMSTradeInQ died.";
	}
	push @CHILDREN, $pid;

	# In Q
	$this->speak("[$$] Forking Incoming Queue Plugin");
	$pid = fork();
	unless ( defined($pid) ) {
		die "[$$] Fork() for Incoming Queue Plugin failed: $!";
	}
	if ( $pid == 0 ) {
		$this->speak("[$$] Running NetSDS::App::SMSTradeInQ");
		my $smsin = new NetSDS::App::SMSTradeInQ();
		$smsin->{conf} = $this->{conf};
		$smsin->run();
		die "[$$] NetSDS::App::SMSTradeInQ died.";
	}
	push @CHILDREN, $pid;

} ## end sub _burn_children

sub start {

	my ($this) = @_;

	$this->speak("[$$] Start SMPPServerV2 ");
	$this->_edr_write( { Event => 'Start Server' } );

	# Connect to authentication DBMS
	$this->mk_accessors('authdbh');
	$this->_connect_db;

	# Do you understand what written here ? Yes:No;
	my $my_local_data = defined( $this->conf->{'shm'}->{'magickey'} ) ? $this->conf->{'shm'}->{'magickey'} : 'My L0c4l D4t4';

	$this->shm->lock(LOCK_EX);
	my $list = decode_json( $this->shm->fetch );
	$list->{$my_local_data}->{'start_timestamp'} = time;
	$this->shm->store( encode_json($list) );
	$this->shm->unlock;

} ## end sub start

sub _auth_esme {

	my ( $this, $login, $passwd ) = @_;

	# Loggin' begin auth procedure
	$this->log( "info", "Begin authentication for \"$login\"" );
	$this->speak("[$$] Begin authentication for \"$login\"");

	# Check DBMS connection and do reconnect if necessary
	unless ( defined( $this->_connect_db() ) ) {
		return undef;
	}
	# Execute SQL query (should be present in configuration file)
	my $sth = $this->authdbh->prepare( $this->conf->{auth}->{query} );
	$sth->execute( $login, $passwd );

	# Try to get one row or return undef
	if ( my $res = $sth->fetchrow_hashref() ) {

		my $system_id = $res->{'system_id'};

		unless ( defined( $ESME->{$system_id} ) ) {    # if this record does not exist in hasref ESME
			$ESME->{$system_id} = $res;                # add it
		}

		unless ( defined( $ESME->{$system_id}->{'already_connected'} ) ) {    # no connections ?
			$this->log( "info", "Setting already_connected to 0" );
			$this->speak("[$$] Setting already_connected to 0");
			$ESME->{$system_id}->{'already_connected'} = 0;
		}

		# if database does not contain max_connections for ESME, default value = 1
		unless ( defined( $res->{'max_connections'} ) ) {
			$ESME->{$system_id}->{'max_connections'} = 1;
			$this->log( "warning", "Max_connections for " . $system_id . " is NULL. Default value set to 1. " );
			$this->speak( "[$$] Max_connections for " . $system_id . " is NULL. Default value set to 1. " );
		} else {
			$ESME->{$system_id}->{'max_connections'} = $res->{'max_connections'};
		}

		# if database does not contain allowed_ip, set default to 0.0.0.0
		unless ( defined( $res->{'allowed_ip'} ) ) {
			$ESME->{$system_id}->{'allowed_ip'} = '0.0.0.0';
			$this->log( "warning", "Allowed src ip for " . $system_id . " is NULL. Default value set to 0.0.0.0 " );
			$this->speak( "[$$] Allowed src ip for " . $system_id . " is NULL. Default value set to 0.0.0.0 " );
		} else {
			$ESME->{$system_id}->{'allowed_ip'} = $res->{'allowed_ip'};
		}

		unless ( defined( $res->{'bandwidth'} ) ) {
			$ESME->{$system_id}->{'bandwidth'} = 1;
			$this->log( "warning", "Setting bandwidth for $system_id to 1/s" );
			$this->speak("[$$] Setting bandwidth for $system_id to 1/s");
		} else {
			$ESME->{$system_id}->{'bandwidth'} = $res->{'bandwidth'};
		}

		unless ( defined( $ESME->{$system_id}->{'received'} ) ) {
			$ESME->{$system_id}->{'received'} = 0;
		}

		unless ( defined( $ESME->{$system_id}->{'sent'} ) ) {
			$ESME->{$system_id}->{'sent'} = 0;
		}

		$this->_edr_write(
			{
				Event  => 'Authentication',
				ESME   => $system_id,
				Status => 'OK',
			}
		);

		return 1; 

	} else {

		$this->_edr_write(
			{
				Event  => 'Authentication',
				ESME   => $login,
				Status => 'FAIL'
			}
		);
		return undef;

	}
} ## end sub _auth_esme

=item B<_increase_received> 

Increase received messages value 

=cut 

sub _increase_received {
	my ( $this, $login ) = @_;

	$ESME->{$login}->{'received'} = $ESME->{$login}->{'received'} + 1;

	$this->shm->lock(LOCK_EX); 
	my $list = decode_json( $this->shm->fetch );
	$list->{$login}->{'received'} = $ESME->{$login}->{'received'};
	$this->shm->store( encode_json($list) );
	$this->shm->unlock;

}

=item B<_increase_sent> 

Increase sent messages value 

=cut 

sub _increase_sent {
	my ( $this, $login ) = @_;

	$ESME->{$login}->{'sent'} = $ESME->{$login}->{'sent'} + 1;
	$this->shm->lock(LOCK_EX);
	my $list = decode_json( $this->shm->fetch );
	$list->{$login}->{'sent'} = $ESME->{$login}->{'sent'};
	$this->shm->store( encode_json($list) );
	$this->shm->unlock;

}

=item B<_increase_already_connected> 

Tries to increase already_connected value for ESME. If it reaches the max_connections will return undef else return 1

=cut 

sub _increase_already_connected {

	my ( $this, $system_id ) = @_;

	my $new_connection_num = $ESME->{$system_id}->{'already_connected'} + 1;
	if ( $new_connection_num > $ESME->{$system_id}->{'max_connections'} ) {
		$this->speak("[$$] ESME \"$system_id\" reached maximum of connections. ");
		$this->log( "warning", "ESME \"$system_id\" reached maximum of connections. " );

		return undef;    # Do not authorize.

	}
	$ESME->{$system_id}->{'already_connected'} = $ESME->{$system_id}->{'already_connected'} + 1;
	$this->speak( "[$$] ESME \"$system_id\" already connected " . $ESME->{$system_id}->{'already_connected'} . " times" );
	$this->log( "info", "ESME \"$system_id\" already connected " . $ESME->{$system_id}->{'already_connected'} . " times" );

	return 1;

}

=item B<_decrease_already_connected> 

Decrease already connected value.

=cut 

sub _decrease_already_connected {

	my ( $this, $login ) = @_;

	unless ( defined( $ESME->{$login} ) ) {
		$this->log( "error", "Try to decrease already_connected for unexistent login $login" );
		$this->speak("[$$] Try to decrease already_connected for unexistent login $login");
		return undef;
	}
	$ESME->{$login}->{'already_connected'} = $ESME->{$login}->{'already_connected'} - 1;
	if ( $ESME->{$login}->{'already_connected'} < 0 ) {
		$this->log( "error", "Decreased already_connected for $login < 0!" );
		$this->speak("[$$] Decreased already_connected for $login < 0!");
		$ESME->{$login}->{'already_connected'} = 0;
		return 1;
	}

	$this->log( "info", "Decrease already_connected for $login to " . $ESME->{$login}->{'already_connected'} );
	$this->speak( "[$$] Decrease already_connected for $login to " . $ESME->{$login}->{'already_connected'} );

	return 1;

} ## end sub _decrease_already_connected

sub _connect_db {

	my ($this) = @_;

	my $dsn    = $this->conf->{'auth'}->{'dsn'};
	my $user   = $this->conf->{'auth'}->{'db-user'};
	my $passwd = $this->conf->{'auth'}->{'db-password'};

	# $this->speak("[$$] Current DSN='".$dsn."'");

	# If DBMS isn' t accessible - try reconnect
	if ( !$this->authdbh or !$this->authdbh->ping ) {
		$this->authdbh( DBI->connect_cached( $dsn, $user, $passwd ) );

		#		$this->authdbh->do("SET CLIENT_ENCODING TO 'UTF-8'");
		#		$this->authdbh->do("SET DATESTYLE TO 'ISO'");

	}

	if ( !$this->authdbh ) {
		$this->speak("Cant connect to DBMS!");
		$this->log( "error", "Cant connect to DBMS!" );
		return undef;
	}

	return 1;

} ## end sub _connect_db

=item B<_init_out_queue) 

Connects to socket of Mobile Terminated Queue Hadler. 

=cut 

sub _init_out_queue {

	my ( $this, %params ) = @_;

	use constant OUT_QUEUE_ADDR  => '127.0.0.1';
	use constant OUT_QUEUE_PORT  => '9999';
	use constant OUT_QUEUE_PROTO => 'tcp';

	my $out_queue_addr  = undef;
	my $out_queue_port  = undef;
	my $out_queue_proto = undef;

	unless ( defined( $this->conf->{'out_queue'}->{'addr'} ) ) {
		$out_queue_addr = OUT_QUEUE_ADDR;
	} else {
		$out_queue_addr = $this->conf->{'out_queue'}->{'addr'};
	}

	unless ( defined( $this->conf->{'out_queue'}->{'port'} ) ) {
		$out_queue_port = OUT_QUEUE_PORT;
	} else {
		$out_queue_port = $this->conf->{'out_queue'}->{'port'};
	}

	unless ( defined( $this->conf->{'out_queue'}->{'proto'} ) ) {
		$out_queue_proto = OUT_QUEUE_PROTO;
	} else {
		$out_queue_proto = $this->conf->{'out_queue'}->{'proto'};
	}

	# Connect to remote socket

	my $connect_failed = 0;

	out_queue_connect:

	$this->out_queue(
		IO::Socket::INET->new(
			PeerAddr => $out_queue_addr,
			PeerPort => $out_queue_port,
			Proto    => $out_queue_proto,
		)
	);

	unless ( defined( $this->out_queue ) ) {
		sleep(1);
		$connect_failed++;
		if ( $connect_failed > 5 ) {

			$this->log(
				"error",
				sprintf(
					"Cant connect to ougoing queue server at %s:%s/%s",
					$out_queue_addr,
					$out_queue_port,
					$out_queue_proto
				)
			);

			die(
				sprintf(
					"ERROR! Cant connect to outgoing queue server at %s:%s/%s",
					$out_queue_addr,
					$out_queue_port,
					$out_queue_proto
				)
			);
		} ## end if ( $connect_failed >...
		goto out_queue_connect;
	} ## end unless ( defined( $this->out_queue...

	$this->out_queue->autoflush(1);

	$this->log( "info", "Successfully connected to OUT Queue server" );

} ## end sub _init_out_queue

sub _init_in_queue {

	my ( $this, %params ) = @_;

	use constant IN_QUEUE_ADDR  => '127.0.0.1';
	use constant IN_QUEUE_PORT  => '9998';
	use constant IN_QUEUE_PROTO => 'tcp';

	my $in_queue_addr  = undef;
	my $in_queue_port  = undef;
	my $in_queue_proto = undef;

	unless ( defined( $this->conf->{'in_queue'}->{'addr'} ) ) {
		$in_queue_addr = IN_QUEUE_ADDR;
	} else {
		$in_queue_addr = $this->conf->{'in_queue'}->{'addr'};
	}

	unless ( defined( $this->conf->{'in_queue'}->{'port'} ) ) {
		$in_queue_port = IN_QUEUE_PORT;
	} else {
		$in_queue_port = $this->conf->{'in_queue'}->{'port'};
	}

	unless ( defined( $this->conf->{'in_queue'}->{'proto'} ) ) {
		$in_queue_proto = IN_QUEUE_PROTO;
	} else {
		$in_queue_proto = $this->conf->{'in_queue'}->{'proto'};
	}

	# Connect to remote socket

	my $connect_failed = 0;

	in_queue_connect:

	$this->in_queue(
		IO::Socket::INET->new(
			PeerAddr => $in_queue_addr,
			PeerPort => $in_queue_port,
			Proto    => $in_queue_proto,
		)
	);

	unless ( defined( $this->in_queue ) ) {
		sleep(1);
		$connect_failed++;
		if ( $connect_failed > 5 ) {

			$this->log(
				"error",
				sprintf(
					"Cant connect to incoming queue server at %s:%s/%s",
					$in_queue_addr,
					$in_queue_port,
					$in_queue_proto
				)
			);

			die(
				sprintf(
					"ERROR! Cant connect to incoming queue server at %s:%s/%s",
					$in_queue_addr,
					$in_queue_port,
					$in_queue_proto
				)
			);
		} ## end if ( $connect_failed >...
		goto in_queue_connect;
	} ## end unless ( defined( $this->in_queue...

	$this->in_queue->autoflush(1);

	$this->log( "info", "Successfully connected to INcoming Queue server" );

} ## end sub _init_in_queue

=itemB<_authorize_submit> 

Checks for allowed_src 

=cut 

sub _authorize_submit {

	my ( $this, $pdu, $hdl ) = @_;

	my $login = $hdl->{system_id};
	my $src   = $pdu->{source_addr};

	unless ( defined( $ESME->{$login}->{'allowed_src'} ) ) {
		# NULL in database
		return 1;
	}
	my @allowed_src = split( ',', $ESME->{$login}->{'allowed_src'} );

	foreach my $source (@allowed_src) {
		$source = str_trim($source);
		if ( $source eq $src ) {

			return 1;
		}
	}
	$this->log( "warning", "Deny send SMS from '$src' for '$login'" );
	$this->speak("[$$] Deny send SMS from '$src' for '$login'");

	return undef;
} ## end sub _authorize_submit

sub _find_current_bandwidth_k {

	my ( $this, $login ) = @_;

	# Find sum of bandwidth of all connected users;
	my $s = 0;
	foreach my $system_id ( keys %$ESME ) {
		$s = $s + $ESME->{$system_id}->{'bandwidth'};
	}
	unless ( defined( $this->{conf}->{'throttle'}->{'bandwidth'} ) ) {
		return 1;    # global throttling not defined. Using unlimited.
	}
	my $global_band = $this->{conf}->{'throttle'}->{'bandwidth'};
	my $user_band   = $ESME->{$login}->{'bandwidth'};

	my $k = floor( $user_band * $global_band ) / $s;

	# Коэффициент глобального ограничения есть ( пользовательское ограничение * глобальное ) / ( сумму всех ограничение всех подключенных пользователей ) . Доказано RAD.

	return $k;

} ## end sub _find_current_bandwidth_k

=item B<_throttling> 

Check for count SMS in seconds 

=cut 

sub _throttling {

	my ( $this, $login ) = @_;

	# If last_message_timestamp does not exist, accept;
	unless ( defined( $ESME->{$login}->{'last_message_timestamp'} ) ) {
		$ESME->{$login}->{'last_message_timestamp'} = time();
		return 1;
	}

	my $last_message_timestamp = $ESME->{$login}->{'last_message_timestamp'};
	my $new_message_timestamp  = time();

	my $difference = $new_message_timestamp - $last_message_timestamp;

	if ( $difference > 0 ) {
		$ESME->{$login}->{'last_message_timestamp'}  = $new_message_timestamp;
		$ESME->{$login}->{'last_second_sm_received'} = 1;
		return 1;    # accept
	}

	if ( $difference < 0 ) {
		$ESME->{$login}->{'last_message_timestamp'}  = $new_message_timestamp;
		$ESME->{$login}->{'last_second_sm_received'} = 1;
		return 1;    # It's stupid error; accept;
	}

	# If difference  == 0; Count messages that was received while current timestamp
	unless ( defined( $ESME->{$login}->{'last_second_sm_received'} ) ) {
		$ESME->{$login}->{'last_second_sm_received'} = 0;
	}
	# Global system bandwidth check
	my $k = $this->_find_current_bandwidth_k($login);
	if ( ( $ESME->{$login}->{'last_second_sm_received'} + 1 ) > $k ) {
		$this->log( "warning", "Deny send SMS from $login for GLOBAL THROTTLING reason." );
		$this->speak("[$$] Deny send SMS from $login for GLOBAL THROTTLING reason.");
		return undef;
	}

	# Local user bandwidth check
	if ( ( $ESME->{$login}->{'last_second_sm_received'} + 1 ) > $ESME->{$login}->{'bandwidth'} ) {
		$this->log( "warning", "Deny send SMS from $login for THROTTLING reason." );
		$this->speak("[$$] Deny send SMS from $login for THROTTLING reason.");
		return undef;
		# Deny
	}

	$ESME->{$login}->{'last_second_sm_received'} = $ESME->{$login}->{'last_second_sm_received'} + 1;
	return 1;    # accept

} ## end sub _throttling

=item B<cmd_submit_sm> 

We are replaced parent method because we need to sent message to IO::Socket::INET not MemcacheQ. 

=cut 

sub cmd_submit_sm {

	my ( $this, $pdu, $hdl ) = @_;

	my %COD_NAME = (
		0 => 'gsm0338',
		1 => '8bit',
		2 => 'ucs2',
	);

	my $resp_status = undef;          # response command status
	my $message_id  = make_uuid();    # message id on CPA (UUID style)

	my $list = decode_json( $this->shm->fetch );
	my $mode = $list->{ $hdl->{system_id} }->{'mode'};

	# Check if client is authenticated
	if (    ( $hdl->{authenticated} )
		and ( $this->_authorize_submit( $pdu, $hdl ) )
		and ( $mode ne 'receiver' ) )
	{

		# Throttling ?

		unless ( defined( $this->_throttling( $hdl->{system_id} ) ) ) {

			$resp_status = 0x00000058;    # ESME_RTHROTTLED

			$hdl->{smpp}->submit_sm_resp(
				seq        => $pdu->{seq},
				status     => $resp_status,
				message_id => $message_id,
				async      => 1,
			);

			return;

		}

		# Create empty message
		my $queue_msg = {
			client   => $hdl->{system_id},
			created  => date_now(),
			received => date_now(),
		};

		unless ( defined( $ESME->{ $hdl->{system_id} } ) ) {
			$queue_msg->{'esme_id'} = undef;

		} else {
			$queue_msg->{'esme_id'} = $ESME->{ $hdl->{system_id} }->{'esme_id'};
		}

		my $mclass = undef;    # default (ME specific according with GSM 03.38)

		# Create UUID for new MT message
		# $message_id = make_uuid();
		$queue_msg->{message_id} = $message_id;

		# Get source and destination addresses
		#	my $src_addr = $pdu->{source_addr};
		#   my $dst_addr = $pdu->{destination_addr};

		$queue_msg->{src_addr} = $pdu->{source_addr};
		$queue_msg->{dst_addr} = $pdu->{destination_addr};

		# **************************************************************************
		#
		# Process data_coding (see ETSI GSM 03.38 specification)
		#
		# Determine: message_class, coding, MWI flags
		#
		my $data_coding = $pdu->{data_coding};

		# Check if message_class is present
		if ( ( $data_coding & 0b00010000 ) eq 0b00010000 ) {
			$mclass = $data_coding & 0b00000011;
		}

		$queue_msg->{mclass} = $mclass;

		# Determine coding
		my $coding = ( $data_coding & 0b00001100 ) >> 2;
		#$queue_msg->{coding_integer} = $coding;

		$queue_msg->{coding} = $coding;

		# Determine UDHI state
		my $udhi      = 0;                    # No UDH by default
		my $esm_class = $pdu->{esm_class};    # see 5.2.12 part of SMPP 3.4 spec
		if ( ( $esm_class & 0b01000000 ) eq 0b01000000 ) {
			$udhi = 1;
		}

		# **************************************************************************
		#
		# Process SM body (UD and UDH)
		#
		my $msg_text = $pdu->{short_message};

		# If have UDH, get if from message
		my $udh = undef;
		if ($udhi) {
			use bytes;
			my ($udhl) = unpack( "C*", bytes::substr( $msg_text, 0, 1 ) );
			$udh = bytes::substr( $msg_text, 0, $udhl + 1 );
			$msg_text = bytes::substr( $msg_text, $udhl + 1 );
			no bytes;
			$queue_msg->{udh} = conv_str_hex($udh);
		}

		# Encode User Data (UD)
		$queue_msg->{body} = conv_str_hex($msg_text);

		# Check if need DLR for message
		if ( $pdu->{registered_delivery} ) {
			$queue_msg->{register_delivery} = '1';
		}

		# Determine TTL for the message
		my $validity_period = $pdu->{validity_period};
		if ( $validity_period =~ /(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(\d)(\d\d)([\-\+R])/ ) {
			$queue_msg->{validity} = "20" . $1 . "-" . $2 . "-" . $3 . " " . $4 . ":" . $5 . ":" . $6;
		}

		# Determine deferred delivery time
		my $schedule_delivery_time = $pdu->{schedule_delivery_time};
		if ( $schedule_delivery_time =~ /(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(\d)(\d\d)([\-\+R])/ ) {
			$queue_msg->{deferred} = "20" . $1 . "-" . $2 . "-" . $3 . " " . $4 . ":" . $5 . ":" . $6;
		}

		# Determine priority
		if ( $pdu->{priority_flag} ) {
			$queue_msg->{priority} = $pdu->{priority_flag} + 0;
		}

		$this->log(
			"info",
			sprintf(
				"MT SM submitted: id='%s', from='%s', to='%s'",
				$queue_msg->{message_id},
				$queue_msg->{src_addr},
				$queue_msg->{dst_addr}
			)
		);

		# Encoding queue_msg to JSON pretty
		my $json_text = to_json( $queue_msg, { ascii => 1, pretty => 1 } );

		# Sending to IN Queue
		my $res = $this->in_queue->print( conv_str_base64($json_text) . "\n" );
		if ( !$res ) {
			$resp_status = 0x45;    # ESME_RSUBMITFAIL
		}
		my $confirm = $this->in_queue->getline;
		if ( $confirm =~ /OK/ ) {
			$resp_status = 0x00;
		} else {
			$resp_status = 0x45;
		}
	} else {
		$resp_status = 0x45;        # ESME_RSUBMITFAIL
	}

	if ( $resp_status != 0x00 ) {

		$this->speak( "[$$] Submit fail from '" . $pdu->{source_addr} . "' to '" . $pdu->{destination_addr} . "' via '" . $hdl->{system_id} . "'" );
		$this->log( "warning", "Submit fail from '" . $pdu->{source_addr} . "' to '" . $pdu->{destination_addr} . "' via '" . $hdl->{system_id} . "'" );

		$this->_edr_write(
			{
				Event          => 'Submit',
				ESME           => $hdl->{system_id},
				Status         => 'FAIL',
				ResponseStatus => $resp_status, 
				MessageId      => $message_id, 
				PduSeq         => $pdu->{seq},
				From           => $pdu->{source_addr}, 
				To             => $pdu->{destination_addr},
				Text           => $pdu->{short_message},
			}
		);

	}
	if ( $resp_status == 0x00 ) {
		$this->_edr_write(
			{
				Event          => 'Submit',
				ESME           => $hdl->{system_id},
				Status         => 'OK',
				ResponseStatus => $resp_status,
				MessageId      => $message_id,
				PduSeq         => $pdu->{seq},
				From           => $pdu->{source_addr}, 
				To             => $pdu->{destination_addr},
				Text           => $pdu->{short_message},
		   }
		);
		$this->_increase_received( $hdl->{system_id} );

	}
	# Send response to ESME
	# Note: we use asynchronous sending to avoid deadlocks
	$hdl->{smpp}->submit_sm_resp(
		seq        => $pdu->{seq},
		status     => $resp_status,
		message_id => $message_id,
		async      => 1,
	);

} ## end sub cmd_submit_sm

sub cmd_unbind {

	my ( $this, $pdu, $hdl ) = @_;

	# warn "[$$] ". Dumper ($pdu);
	my $system_id = $hdl->{system_id};

	my $resp = $hdl->{smpp}->unbind_resp(
		seq    => $pdu->{seq},
		status => $pdu->{status},
	);

	# decrease already connected value for system_id
	$this->_decrease_already_connected( $hdl->{system_id} );

	# Update SHM struture (only for defined system_id)
	if ( $hdl->{system_id} ) {
		if ( $ESME->{$system_id}->{'already_connected'} <= 0 ) {
			# If it was last connect, remove ESME from SHM
			$this->shm->lock(LOCK_EX);
			my $list = decode_json( $this->shm->fetch );
			delete $list->{ $hdl->{system_id} };
			$this->shm->store( encode_json($list) );
			$this->shm->unlock;
		} else {
			# ELSE Just decrease already_connected value in SHM
			$this->shm->lock(LOCK_EX);
			my $list = decode_json( $this->shm->fetch );
			$list->{$system_id}->{'already_connected'} = $ESME->{$system_id}->{'already_connected'};
			$this->shm->store( encode_json($list) );
			$this->shm->unlock;
		}
	}

	# Remove socket from select()
	$this->selector->remove( $hdl->{smpp} );

	# Close socket and remove record
	$hdl->{smpp}->close();
	delete $this->{handlers}->{ $hdl->{id} };

	$this->_edr_write(
		{
			Event => 'Unbind',
			ESME  => $hdl->{system_id}
		}
	);

}    # end sub cmd unbind

=item B<_acl_source_ip> 

Check allowed_ip field for peer host src ip. 

=cut 

sub _acl_source_ip {

	my ( $this, $login, $peer ) = @_;

	if ( $ESME->{$login}->{'allowed_ip'} eq '0.0.0.0' ) {
		$this->log( "warning", "Allowed src ip for $login is anywhere (0.0.0.0). OK." );
		$this->speak("[$$] Allowed src ip for $login is anywhere (0.0.0.0). OK.");
		return 1;
	}

	my ( $peerhost, $peerport ) = split( ':', $peer );

	my (@allowed) = split( ',', $ESME->{$login}->{'allowed_ip'} );

	$this->log( "info", $login . ": peer : '" . $peerhost . "' : allowed : '" . $ESME->{$login}->{'allowed_ip'} . "'" );
	$this->speak( "[$$] $login: peer : '" . $peerhost . "' : allowed : '" . $ESME->{$login}->{'allowed_ip'} . "'" );

	foreach my $host (@allowed) {
		$host = str_trim($host);
		if ( $host eq $peerhost ) {
			$this->log( "info", $login . " allow from " . $peerhost );
			$this->speak( "[$$] $login  allow from " . $peerhost );
			return 1;
		}
	}
	$this->log( "warning", $login . " deny from " . $peerhost );
	$this->speak("[$$] $login deny from $peerhost");

	return undef;

} ## end sub _acl_source_ip

sub _authorize_esme {

	my ( $this, $login, $hdl ) = @_;

	my $resp_status = 0x00000000;

	unless ( defined( $this->_acl_source_ip( $login, $hdl->{id} ) ) ) {
		return 0x0000000E;    # ESME_RINVPASWD
	}

	unless ( defined( $this->_increase_already_connected($login) ) ) {
		return 0x0000000E;    # ESME_RINVPASWD
	}

	return 0x00000000;        # OK
}

#
# bind_transiever called when ESME connect to us in transiever mode (send and receive SMS in one connection )
#

sub cmd_bind_transceiver {

	my ( $this, $pdu, $hdl ) = @_;

	# Determine incoming login (system-id) and password
	my $login  = $pdu->{system_id};
	my $passwd = $pdu->{password};

	my $resp_status = 0x00000000;    # All OK

	# Send error status if already authenticated
	if ( $hdl->{authenticated} ) {
		$this->speak("[$$] Already binded ESME authentication: $login");
		$this->log( "warning", "Already binded ESME authentication: $login" );

		if ( $this->_increase_already_connected($login) ) {
			$resp_status = 0x00000005;    # Already in bind state
		} else {
			$resp_status = 0x0000000E;    # Do not authorize
		}

	} else {

		# Authentication
		if ( $this->_auth_esme( $login, $passwd ) ) {
			$this->speak("[$$] ESME '$login' successfully authenticated");
			$this->log( "info", "ESME '$login' successfully authenticated" );

			$resp_status = $this->_authorize_esme( $login, $hdl );
			if ( $resp_status == 0x00 ) {

				# Update handlers
				$this->{handlers}->{ $hdl->{id} }->{authenticated} = 1;
				$this->{handlers}->{ $hdl->{id} }->{system_id}     = $login;
				$this->{handlers}->{ $hdl->{id} }->{mode}          = 'transceiver';

				# Update SHM struture
				my $list = decode_json( $this->shm->fetch );

				$list->{$login}->{'esme_id'}           = $ESME->{$login}->{'esme_id'};
				$list->{$login}->{'mode'}              = 'transciever';
				$list->{$login}->{'bandwidth'}         = $ESME->{$login}->{'bandwidth'};
				$list->{$login}->{'already_connected'} = $ESME->{$login}->{'already_connected'};
				$list->{$login}->{'sent'}              = $ESME->{$login}->{'sent'};
				$list->{$login}->{'received'}          = $ESME->{$login}->{'received'};

				$this->shm->lock(LOCK_EX);
				$this->shm->store( encode_json($list) );
				$this->shm->unlock;
			} ## end if ( $resp_status == 0x00)

		} else {
			$this->log( "warning", "Cant authenticate ESME: [$login:$passwd]" );
			$this->speak("Cant authenticate ESME: [$login:$passwd]");
			$resp_status = 0x0000000E;    # ESME_RINVPASWD

			# Send ESME_RINVPASWD
			my $resp = $hdl->{smpp}->bind_transceiver_resp(
				seq       => $pdu->{seq},
				status    => $resp_status,
				system_id => NetSDS::App::SMPP::SYSTEM_NAME,
			);

			# Close socket
			# Remove socket from select()
			$this->selector->remove( $hdl->{smpp} );

			# Close socket and remove record
			$hdl->{smpp}->close();
			#undef $this->{handlers}->{ $hdl->{id} };
			delete $this->{handlers}->{ $hdl->{id} };

		} ## end else [ if ( $this->_auth_esme...
	} ## end else [ if ( $hdl->{authenticated...

	my $status = undef;

	if ( $resp_status == 0x00 ) {
		$status = 'OK';
	} else {
		$status = 'FAIL';
	}

	$this->_edr_write(
		{
			Event      => 'Bind Transciever',
			ESME       => $login,
			Status     => $status,
			RespStatus => $resp_status

		}
	);

	my $resp = $hdl->{smpp}->bind_transceiver_resp(
		seq       => $pdu->{seq},
		status    => $resp_status,                     # ESME_ROK
		system_id => NetSDS::App::SMPP::SYSTEM_NAME,
	);

} ## end sub cmd_bind_transceiver

sub cmd_bind_transmitter {

	my ( $this, $pdu, $hdl ) = @_;

	# Determine incoming login (system-id) and password
	my $login  = $pdu->{system_id};
	my $passwd = $pdu->{password};

	my $resp_status = 0x00000000;    # All OK

	# Send error status if already authenticated
	if ( $hdl->{authenticated} ) {

		$this->log( "warning", "Already binded ESME authentication: $login" );
		$this->speak("[$$] Already binded ESME authentication: $login");
		if ( $this->_increase_already_connected($login) ) {
			$resp_status = 0x00000005;    # Already in bind state
		} else {
			$resp_status = 0x0000000E;    # Do not authorize
		}

	} else {

		# Authentication
		if ( $this->_auth_esme( $login, $passwd ) ) {
			$this->speak("[$$] ESME '$login' successfully authenticated");
			$this->log( "info", "ESME '$login' successfully authenticated" );
			$resp_status = $this->_authorize_esme( $login, $hdl );
			if ( $resp_status == 0x00 ) {

				# Update handlers
				$this->{handlers}->{ $hdl->{id} }->{authenticated} = 1;
				$this->{handlers}->{ $hdl->{id} }->{system_id}     = $login;
				$this->{handlers}->{ $hdl->{id} }->{mode}          = 'transmitter';

				# Update SHM struture
				my $list = decode_json( $this->shm->fetch );

				$list->{$login}->{'esme_id'}           = $ESME->{$login}->{'esme_id'};
				$list->{$login}->{'mode'}              = 'transmitter';
				$list->{$login}->{'bandwidth'}         = $ESME->{$login}->{'bandwidth'};
				$list->{$login}->{'already_connected'} = $ESME->{$login}->{'already_connected'};
				$list->{$login}->{'sent'}              = $ESME->{$login}->{'sent'};
				$list->{$login}->{'received'}          = $ESME->{$login}->{'received'};

				$this->shm->lock(LOCK_EX);
				$this->shm->store( encode_json($list) );
				$this->shm->unlock;

			} ## end if ( $resp_status == 0x00)

		} else {
			$this->log( "warning", "Cant authenticate ESME: [$login:$passwd]" );
			$this->speak("Cant authenticate ESME: [$login:$passwd]");
			$resp_status = 0x0000000E;    # ESME_RINVPASWD
			my $resp = $hdl->{smpp}->bind_transmitter_resp(
				seq       => $pdu->{seq},
				status    => $resp_status,                     # ESME_RINVPASWD
				system_id => NetSDS::App::SMPP::SYSTEM_NAME,
			);
			# Close socket
			# Remove socket from select()
			$this->selector->remove( $hdl->{smpp} );

			# Close socket and remove record
			$hdl->{smpp}->close();
			delete $this->{handlers}->{ $hdl->{id} };
			# undef $this->{handlers}->{ $hdl->{id} };

		}
	} ## end else [ if ( $hdl->{authenticated...

	my $status = undef;
	if ( $resp_status == 0x00 ) {
		$status = 'OK';
	} else {
		$status = 'FAIL';
	}
	$this->_edr_write(
		{
			Event      => 'Bind Transmitter',
			ESME       => $login,
			Status     => $status,
			RespStatus => $resp_status

		}
	);

	my $resp = $hdl->{smpp}->bind_transmitter_resp(
		seq       => $pdu->{seq},
		status    => $resp_status,                     # ESME_ROK
		system_id => NetSDS::App::SMPP::SYSTEM_NAME,
	);

} ## end sub cmd_bind_transmitter

sub cmd_bind_receiver {

	my ( $this, $pdu, $hdl ) = @_;

	# Determine incoming login (system-id) and password
	my $login  = $pdu->{system_id};
	my $passwd = $pdu->{password};

	my $resp_status = 0x00000000;    # All OK

	# Send error status if already authenticated
	if ( $hdl->{authenticated} ) {

		$this->log( "warning", "Already binded ESME authentication: $login" );
		if ( $this->_increase_already_connected($login) ) {
			$resp_status = 0x00000005;    # Already in bind state
		} else {
			$resp_status = 0x0000000E;    # Do not authorize
		}

	} else {

		# Authentication
		if ( $this->_auth_esme( $login, $passwd ) ) {
			$this->speak("ESME '$login' successfully authenticated");
			$this->log( "info", "ESME '$login' successfully authenticated" );
			$resp_status = $this->_authorize_esme( $login, $hdl );
			if ( $resp_status == 0x00 ) {

				# Update handlers
				$this->{handlers}->{ $hdl->{id} }->{authenticated} = 1;
				$this->{handlers}->{ $hdl->{id} }->{system_id}     = $login;
				$this->{handlers}->{ $hdl->{id} }->{mode}          = 'receiver';

				# Update SHM struture
				my $list = decode_json( $this->shm->fetch );

				$list->{$login}->{'esme_id'}           = $ESME->{$login}->{'esme_id'};
				$list->{$login}->{'mode'}              = 'receiver';
				$list->{$login}->{'bandwidth'}         = $ESME->{$login}->{'bandwidth'};
				$list->{$login}->{'already_connected'} = $ESME->{$login}->{'already_connected'};
				$list->{$login}->{'sent'}              = $ESME->{$login}->{'sent'};
				$list->{$login}->{'received'}          = $ESME->{$login}->{'received'};

				$this->shm->lock(LOCK_EX);
				$this->shm->store( encode_json($list) );
				$this->shm->unlock;
			} ## end if ( $resp_status == 0x00)

		} else {
			$this->log( "warning", "Cant authenticate ESME: [$login:$passwd]" );
			$this->speak("Cant authenticate ESME: [$login:$passwd]");
			$resp_status = 0x0000000E;    # ESME_RINVPASWD

			my $resp = $hdl->{smpp}->bind_receiver_resp(
				seq       => $pdu->{seq},
				status    => $resp_status,                     # ESME_RINVPASWD
				system_id => NetSDS::App::SMPP::SYSTEM_NAME,
			);

			# Close socket
			# Remove socket from select()
			$this->selector->remove( $hdl->{smpp} );

			# Close socket and remove record
			$hdl->{smpp}->close();
			#undef $this->{handlers}->{ $hdl->{id} };
			delete $this->{handlers}->{ $hdl->{id} };

		} ## end else [ if ( $this->_auth_esme...
	} ## end else [ if ( $hdl->{authenticated...

	my $status = undef;
	if ( $resp_status == 0x00 ) {
		$status = 'OK';
	} else {
		$status = 'FAIL';
	}
	$this->_edr_write(
		{
			Event      => 'Bind Receiver',
			ESME       => $login,
			Status     => $status,
			RespStatus => $resp_status
		}
	);

	my $resp = $hdl->{smpp}->bind_receiver_resp(
		seq       => $pdu->{seq},
		status    => $resp_status,                     # ESME_ROK
		system_id => NetSDS::App::SMPP::SYSTEM_NAME,
	);

} ## end sub cmd_bind_receiver

sub _process_out_queue {
	my ( $this, %params ) = @_;

	# Try to get next line from Queue server over TCP socket
	if ( my $line = $this->out_queue->getline() ) {

		# Return if keepalive
		if ( $line =~ '-MARK-' ) {
			$this->speak("Keepalive from queue server");
			return 1;
		}

		my $mo = decode_json( conv_base64_str($line) );

		# Check if exist in MO esme_id
		unless ( defined( $mo->{'esme_id'} ) ) {
			$this->speak("[$$] MO with empty esme_id");
			$this->log( "warning", "MO with empty esme_id" );
		} else {
			# esme_id is not empty, searching system_id and socket
			foreach my $esme ( keys %$ESME ) {
				unless ( defined( $ESME->{$esme}->{'esme_id'} ) ) { next; }
				if ( $ESME->{$esme}->{'esme_id'} eq $mo->{'esme_id'} ) {
					$mo->{'system_id'} = $esme;
					last;
				}
			}

			# Looking for proper ESME connect
			my $esme_connect_found = 0;
			my @esme_connects      = ();

			foreach my $hdl ( values %{ $this->handlers } ) {
				unless ( defined( $hdl->{system_id} ) ) { next; }
				if ( $hdl->{system_id} eq $mo->{'system_id'} ) {
					if ( ( $hdl->{mode} eq 'transceiver' ) or ( $hdl->{mode} eq 'receiver' ) ) {
						# Found connect. Push IT.
						push @esme_connects, $hdl;
						$esme_connect_found = $esme_connect_found + 1;
					}
				}
			}

			if ( $esme_connect_found <= 0 ) {
				$this->speak( "[$$] ESME " . $mo->{'system_id'} . "not found in active list. " );
				$this->log( "warning", "ESME " . $mo->{'system_id'} . "not found in active list. " );
				$this->out_queue->print("ERROR\n");
			} else {
				my $hdl_index = rand($esme_connect_found);    # Select random connect
				my $hdl       = $esme_connects[$hdl_index];
				$this->_deliver_sm( $hdl, $mo );              # send deliver_sm to ESME
				$this->out_queue->print("OK\n");

			}

		} ## end else

	} ## end if ( my $line = $this->out_queue...
} ## end sub _process_out_queue

sub _deliver_sm {

	my ( $this, $hdl, $mo ) = @_;

	if ( $mo->{id} ) {

		# Set default parameters (for MO SM)
		my $message_id       = $mo->{id};
		my $esm_class        = $mo->{mclass};
		my $source_addr_ton  = 0x01;
		my $source_addr_npi  = 0x01;
		my $source_addr      = $mo->{src_addr};
		my $dest_addr_ton    = 0x00;
		my $dest_addr_npi    = 0x01;
		my $destination_addr = $mo->{dst_addr};
		my $msg_text         = $mo->{text};
		my $data_coding      = $mo->{coding};

		# Set ESM class
		#if ( $mo->{dlr} ) {
		#		$esm_class = 0x04;    # DLR
		#}

		my $system_id = $hdl->{system_id};
		$this->speak("[$$] Deliver SM from '$source_addr' to '$destination_addr' via '$system_id' ");
		$this->log( "info", "Deliver SM from '$source_addr' to '$destination_addr' via '$system_id'" );

		# Send deliver_sm
		$hdl->{smpp}->deliver_sm(
			source_addr_ton  => $source_addr_ton,    # International (MSISDN)
			source_addr_npi  => $source_addr_npi,    # E.164
			source_addr      => $source_addr,
			dest_addr_ton    => $dest_addr_ton,      # Unknown (default)
			dest_addr_npi    => $dest_addr_npi,      # E.164
			destination_addr => $destination_addr,
			esm_class        => $esm_class,          # MO data (UDH + UD) or DLR
			short_message    => $msg_text,
			async            => 1,
			data_coding      => $data_coding,
		);

	} ## end if ( $mo->{id} )

	$hdl->{out_seq}++;

	$this->_edr_write(
		{
			Event  => 'Deliver',
			ESME   => $hdl->{system_id},
			Status => 'OK'
		}
	);

	$this->_increase_sent( $hdl->{system_id} );

} ## end sub _deliver_sm

sub _process_socket {
	my ( $this, $hdl ) = @_;

	# Determine peer IP and port
	my $peer_addr = $hdl->{smpp}->peerhost;
	my $peer_port = $hdl->{smpp}->peerport;

	# Try to read PDU
	my $pdu = $hdl->{smpp}->read_pdu();

	if ( !$pdu ) {

		# Disconnect if EOF
		if ( $hdl->{smpp}->eof() ) {

			$this->speak("[$$] EOF from ${peer_addr}:${peer_port}");
			$this->log( "warning", "EOF from ${peer_addr}:${peer_port}" );

			if ( $hdl->{system_id} ) {
				$this->_decrease_already_connected( $hdl->{system_id} );
			}

			# Remove socket from select()
			$this->selector->remove( $hdl->{smpp} );

			# Close socket and remove record
			$hdl->{smpp}->close();
			delete $this->{handlers}->{ $hdl->{id} };

			my $login = $hdl->{system_id};
			# Update SHM struture (only for defined system_id)
			if ( $hdl->{system_id} ) {
				if ( $ESME->{$login}->{'already_connected'} <= 0 ) {
					$this->shm->lock(LOCK_EX);
					my $list = decode_json( $this->shm->fetch );
					delete $list->{ $hdl->{system_id} };
					$this->shm->store( encode_json($list) );
					$this->shm->unlock;
				} else {
					$this->shm->lock(LOCK_EX);
					my $list = decode_json( $this->shm->fetch );
					$list->{$login}->{'already_connected'} = $ESME->{$login}->{'already_connected'};
					$this->shm->store( encode_json($list) );
					$this->shm->unlock;
				}
			}

		} else {

			$this->speak("[$$] Incoming event arrived but no SMPP PDU!");
			$this->log( "warning", "Incoming event arrived from [${peer_addr}:${peer_port}] but no SMPP PDU!" );
		}

	} else {

		# Process incoming PDU
		my $pdu_cmd = "unknown";
		if ( cmd_tab->{ $pdu->{cmd} } ) {
			$pdu_cmd = cmd_tab->{ $pdu->{cmd} };
		}

		$this->speak("[$$] PDU arrived: $pdu_cmd");

		# Determine method name to dispatch PDU call
		my $method_name = "cmd_" . $pdu_cmd;

		if ( $pdu_cmd eq 'enquire_link' ) {

			# process enqiure_link locally
			$this->cmd_enquire_link( $pdu, $hdl );

		} elsif ( ( $pdu_cmd =~ /^bind_(transceiver|transmitter|receiver)/ ) and $this->can($method_name) ) {

			# Process known authentication methods
			$this->$method_name( $pdu, $hdl );

		} elsif ( $this->can($method_name) and $hdl->{authenticated} ) {

			# process known PDUs
			$this->$method_name( $pdu, $hdl );

		} else {

			# PDU unknown - damn it
			$this->cmd_unknown( $pdu, $hdl );

		}

	} ## end else [ if ( !$pdu )

} ## end sub _process_socket

sub _kick {
	my $this = shift;

	my $list = decode_json( $this->shm->fetch );
	foreach my $login ( keys %$list ) {
		if ( defined( $list->{$login}->{'kick'} ) ) {
			$this->_shutup($login);
		}
	}
}

sub _reload {
	my $this = shift;

}

sub _shutup {
	my ( $this, $login ) = @_;

	foreach my $hdl ( values %{ $this->handlers } ) {
		my $system_id = $hdl->{'system_id'};
		if ( $system_id eq $login ) {
			my $seq = $hdl->{smpp}->unbind();
		}
	}
}

1;
#===============================================================================

__END__

=head1 NAME

smppd.pl

=head1 SYNOPSIS

smppd.pl

=head1 DESCRIPTION

FIXME

=head1 EXAMPLES

FIXME

=head1 BUGS

Unknown.

=head1 TODO

Empty.

=head1 AUTHOR

Michael Bochkaryov <misha@rattler.kiev.ua>
Alex Radetsky <rad@rad.kiev.ua>


=cut

